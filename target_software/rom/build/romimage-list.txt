------- FILE main.dasm LEVEL 1 PASS 2
      1  10000 ????						; vim: setlocal ft=asmM6502:
      2  10000 ????
      3  10000 ????				       processor	6502
      4  10000 ????
      5  10000 ????
      6  10000 ????
      7  c000					      org	$C000
      8  c000				   irqHandler
      9  c000				   nmiHandler
     10  c000		       4c 00 c0 	      jmp	*
     11  c003
     12  c003				   resetHandler
     13  c003		       20 69 c0 	      jsr	start_monitor
     14  c006		       4c 06 c0 	      jmp	*	; Shouldn't reach here.
     15  c009
------- FILE utils.dasm LEVEL 2 PASS 2
      0  c009					      include	"utils.dasm"
      1  c009					      processor	6502
      2  c009
      3  c009					      mac	strlen
      4  c009					      lda	#<[{1}]	; Store the address of the string at $0000
      5  c009					      sta	$0
      6  c009					      lda	#>[{1}]
      7  c009					      sta	$1
      8  c009					      jsr	strlen_impl
      9  c009					      endm
     10  c009
     11  c009					      mac	strlen_indir
     12  c009					      lda	{1}	; Store the address of the string at $0000
     13  c009					      sta	$0
     14  c009					      lda	{1} + 1
     15  c009					      sta	$1
     16  c009					      jsr	strlen_impl
     17  c009					      endm
     18  c009
     19  c009				   strlen_impl subroutine		; Stores length of string in acc
     20  c009		       a0 00		      ldy	#0
     21  c00b				   .strlen_loop
     22  c00b		       b1 00		      lda	($0),y
     23  c00d		       f0 04		      beq	.strlen_done
     24  c00f		       c8		      iny
     25  c010		       4c 0b c0 	      jmp	.strlen_loop
     26  c013				   .strlen_done
     27  c013		       98		      tya
     28  c014		       60		      rts
     29  c015
     30  c015					      mac	hex_byte_string_to_num
     31  c015							; Check first digit
     32  c015					      lda	{1}
     33  c015					      jsr	is_hex
     34  c015					      bne	.not_hex_string
     35  c015					      lda	{1}
     36  c015					      jsr	hex_to_nibble
     37  c015					      clc
     38  c015					      rol
     39  c015					      rol
     40  c015					      rol
     41  c015					      rol
     42  c015					      sta	$0
     43  c015
     44  c015							; Check second digit
     45  c015					      lda	{1} + 1
     46  c015					      jsr	is_hex
     47  c015					      bne	.not_hex_string
     48  c015					      lda	{1} + 1
     49  c015					      jsr	hex_to_nibble
     50  c015					      clc
     51  c015					      ora	$0
     52  c015
     53  c015					      jmp	.done_hex
     54  c015
     55  c015				   .not_hex_string
     56  c015					      jmp	{2}
     57  c015
     58  c015				   .done_hex
     59  c015
     60  c015					      endm
     61  c015
     62  c015				   nibble_to_hex subroutine
     63  c015		       c9 0a		      cmp	#$A
     64  c017		       b0 03		      bcs	.gt_9
     65  c019		       69 30		      adc	#$30	; 0-9, so offset to 0
     66  c01b		       60		      rts
     67  c01c
     68  c01c				   .gt_9		; Greater than 9, so we need to offset to A - 10
     69  c01c		       69 36		      adc	#$36
     70  c01e		       60		      rts
     71  c01f
     72  c01f				   num_to_hex_string subroutine		; Convert num in acc to hex. Stores in $00-$01
     73  c01f		       48		      pha
     74  c020		       29 f0		      and	#$F0
     75  c022		       4a		      lsr
     76  c023		       4a		      lsr
     77  c024		       4a		      lsr
     78  c025		       4a		      lsr
     79  c026		       20 15 c0 	      jsr	nibble_to_hex
     80  c029		       85 00		      sta	$00
     81  c02b		       68		      pla
     82  c02c		       29 0f		      and	#$0F
     83  c02e		       20 15 c0 	      jsr	nibble_to_hex
     84  c031		       85 01		      sta	$01
     85  c033		       a9 00		      lda	#$0
     86  c035		       85 02		      sta	$02
     87  c037		       60		      rts
     88  c038
     89  c038				   is_hex     subroutine		; Checks if ASCII value in acc is a hex digit
     90  c038		       c9 30		      cmp	#$30
     91  c03a		       90 12		      bcc	.not_hex
     92  c03c		       c9 3a		      cmp	#$3A
     93  c03e		       b0 03		      bcs	.not_a_number
     94  c040		       a9 00		      lda	#$0
     95  c042		       60		      rts
     96  c043				   .not_a_number
     97  c043		       c9 41		      cmp	#$41
     98  c045		       90 07		      bcc	.not_hex
     99  c047		       c9 47		      cmp	#$47
    100  c049		       b0 03		      bcs	.not_hex
    101  c04b		       a9 00		      lda	#$0
    102  c04d		       60		      rts
    103  c04e				   .not_hex
    104  c04e		       a9 01		      lda	#$1
    105  c050		       60		      rts
    106  c051
    107  c051				   hex_to_nibble subroutine		; Convert ascii hex to nibble
    108  c051		       c9 41		      cmp	#$41	; Is it a letter? (A-F)
    109  c053		       b0 03		      bcs	.letter
    110  c055		       e9 2f		      sbc	#$2F
    111  c057		       60		      rts
    112  c058				   .letter
    113  c058		       e9 37		      sbc	#$37
    114  c05a		       60		      rts
    115  c05b
------- FILE main.dasm
------- FILE uart.dasm LEVEL 2 PASS 2
      0  c05b					      include	"uart.dasm"
      1  c05b							; vim: setlocal ft=asmM6502:
      2  c05b
      3  c05b					      processor	6502
      4  c05b
      5  c05b							; UART Register locations
      6  c05b		       02 00	   DUART_BASE equ	$0200
      7  c05b		       02 03	   DUART_TX_A equ	DUART_BASE + 3
      8  c05b		       02 03	   DUART_RX_A equ	DUART_BASE + 3
      9  c05b
     10  c05b		       02 01	   DUART_STATUS_A equ	DUART_BASE + 1
     11  c05b
     12  c05b					      mac	uarta_puts
     13  c05b					      lda	#<[{1}]	; Store the address of the string at $0000
     14  c05b					      sta	$0
     15  c05b					      lda	#>[{1}]
     16  c05b					      sta	$1
     17  c05b					      jsr	uarta_puts_impl
     18  c05b					      endm
     19  c05b
     20  c05b					      mac	uarta_puts_indir
     21  c05b					      lda	{1}	; Store the pointer to the string at $0000
     22  c05b					      sta	$0
     23  c05b					      lda	{1}+1
     24  c05b					      sta	$1
     25  c05b					      jsr	uarta_puts_impl
     26  c05b					      endm
     27  c05b
     28  c05b				   uarta_puts_impl subroutine
     29  c05b		       a0 00		      ldy	#0
     30  c05d				   .uarta_puts_loop
     31  c05d		       b1 00		      lda	($0),y
     32  c05f		       f0 07		      beq	.uarta_puts_done
     33  c061		       8d 03 02 	      sta	DUART_TX_A
     34  c064		       c8		      iny
     35  c065		       4c 5d c0 	      jmp	.uarta_puts_loop
     36  c068				   .uarta_puts_done
     37  c068		       60		      rts
     38  c069
     39  c069
     40  c069					      mac	uarta_putb
     41  c069					      sta	DUART_TX_A
     42  c069					      endm
     43  c069
     44  c069
     45  c069					      mac	uarta_getb
     46  c069					      lda	DUART_RX_A
     47  c069					      endm
     48  c069
     49  c069
     50  c069					      mac	uarta_bytes_available
     51  c069					      lda	#$01	; Perform a bit test on the RX_RDY bit in status reg
     52  c069					      bit	DUART_STATUS_A
     53  c069					      endm
     54  c069
     55  c069
------- FILE main.dasm
------- FILE monitor.dasm LEVEL 2 PASS 2
      0  c069					      include	"monitor.dasm"
      1  c069
      2  c069					      processor	6502
      3  c069
      4  c069		       00 80	   M_STR_BASE equ	$80
      5  c069		       00 10	   M_STR_LEN  equ	$10
      6  c069		       00 11	   M_HEX_RECORD_LEN equ	$11
      7  c069		       00 12	   M_HEX_RECORD_ADDR equ	$12
      8  c069		       00 14	   M_TEMP_ADDR equ	$14
      9  c069		       00 16	   M_CURRENT_ADDR equ	$16
     10  c069
     11  c069				   start_monitor subroutine
      0  c069					      uarta_puts	monitorInfoText
      1  c069		       a9 ef		      lda	#<[monitorInfoText]
      2  c06b		       85 00		      sta	$0
      3  c06d		       a9 c3		      lda	#>[monitorInfoText]
      4  c06f		       85 01		      sta	$1
      5  c071		       20 5b c0 	      jsr	uarta_puts_impl
     13  c074
     14  c074				   .monitor_loop
     15  c074		       a9 24		      lda	#$24	; Write the prompt ('$ ')
      0  c076					      uarta_putb
      1  c076		       8d 03 02 	      sta	DUART_TX_A
     17  c079		       a9 20		      lda	#$20
      0  c07b					      uarta_putb
      1  c07b		       8d 03 02 	      sta	DUART_TX_A
     19  c07e
     20  c07e		       20 88 c0 	      jsr	monitor_get_string	; Print the string with surrounding quotes
     21  c081		       20 c3 c0 	      jsr	monitor_parse_command
     22  c084		       4c 74 c0 	      jmp	.monitor_loop
     23  c087		       60		      rts
     24  c088
     25  c088				   monitor_get_string subroutine
     26  c088		       a0 00		      ldy	#$0
     27  c08a
     28  c08a				   .check_char
      0  c08a					      uarta_bytes_available
      1  c08a		       a9 01		      lda	#$01
      2  c08c		       2c 01 02 	      bit	DUART_STATUS_A
     30  c08f		       f0 1b		      beq	.no_char	; No character available
     31  c091
      0  c091					      uarta_getb		; Get byte from UART
      1  c091		       ad 03 02 	      lda	DUART_RX_A
     33  c094
     34  c094		       c9 0a		      cmp	#$0A	; Check if it's a newline
     35  c096		       f0 22		      beq	.newline
     36  c098		       c9 08		      cmp	#$08	; Check if it's a backspace
     37  c09a		       f0 13		      beq	.backspace
     38  c09c
     39  c09c		       aa		      tax
     40  c09d		       c0 7f		      cpy	#$7F	; Make sure buffer doesn't overrun
     41  c09f		       f0 e9		      beq	.check_char
     42  c0a1		       8a		      txa
     43  c0a2
     44  c0a2				   .store_char
     45  c0a2		       99 80 00 	      sta	M_STR_BASE,y
     46  c0a5		       c8		      iny
      0  c0a6					      uarta_putb
      1  c0a6		       8d 03 02 	      sta	DUART_TX_A
     48  c0a9		       4c 8a c0 	      jmp	.check_char
     49  c0ac
     50  c0ac				   .no_char
     51  c0ac		       4c 8a c0 	      jmp	.check_char
     52  c0af
     53  c0af				   .backspace
     54  c0af		       c0 00		      cpy	#$0
     55  c0b1		       f0 04		      beq	.backspace_done
     56  c0b3		       88		      dey		; Remove character if y > 0
      0  c0b4					      uarta_putb
      1  c0b4		       8d 03 02 	      sta	DUART_TX_A
     58  c0b7				   .backspace_done
     59  c0b7		       4c 8a c0 	      jmp	.check_char
     60  c0ba
     61  c0ba				   .newline
      0  c0ba					      uarta_putb
      1  c0ba		       8d 03 02 	      sta	DUART_TX_A
     63  c0bd		       a9 00		      lda	#$0
     64  c0bf		       99 80 00 	      sta	M_STR_BASE,y	; Add null terminator
     65  c0c2		       60		      rts
     66  c0c3
     67  c0c3
     68  c0c3							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     69  c0c3							;
     70  c0c3							; monitor_parse_command
     71  c0c3							;
     72  c0c3							; Parses the command present at MONITOR_STR_BASE
     73  c0c3							;
     74  c0c3							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     75  c0c3
     76  c0c3				   monitor_parse_command subroutine
      0  c0c3					      strlen	M_STR_BASE
      1  c0c3		       a9 80		      lda	#<[M_STR_BASE]
      2  c0c5		       85 00		      sta	$0
      3  c0c7		       a9 00		      lda	#>[M_STR_BASE]
      4  c0c9		       85 01		      sta	$1
      5  c0cb		       20 09 c0 	      jsr	strlen_impl
     78  c0ce		       85 10		      sta	M_STR_LEN
     79  c0d0
     80  c0d0							; If there are no characters, just return
     81  c0d0		       c9 00		      cmp	#$0
     82  c0d2		       d0 01		      bne	.parse_command
     83  c0d4		       60		      rts
     84  c0d5
     85  c0d5				   .parse_command
     86  c0d5		       a5 80		      lda	M_STR_BASE
     87  c0d7
     88  c0d7							; Check if Intel hex (starts with :)
     89  c0d7		       c9 3a		      cmp	#':
     90  c0d9		       d0 04		      bne	.not_iHex
     91  c0db		       20 23 c1 	      jsr	monitor_parse_ihex
     92  c0de		       60		      rts
     93  c0df
     94  c0df				   .not_iHex
     95  c0df		       c9 3f		      cmp	#'?
     96  c0e1		       d0 0c		      bne	.not_help
      0  c0e3					      uarta_puts	monitorHelpText
      1  c0e3		       a9 93		      lda	#<[monitorHelpText]
      2  c0e5		       85 00		      sta	$0
      3  c0e7		       a9 c4		      lda	#>[monitorHelpText]
      4  c0e9		       85 01		      sta	$1
      5  c0eb		       20 5b c0 	      jsr	uarta_puts_impl
     98  c0ee		       60		      rts
     99  c0ef
    100  c0ef				   .not_help
    101  c0ef		       c9 61		      cmp	#'a
    102  c0f1		       d0 04		      bne	.not_address
    103  c0f3		       20 33 c2 	      jsr	monitor_current_address
    104  c0f6		       60		      rts
    105  c0f7
    106  c0f7				   .not_address
    107  c0f7		       c9 78		      cmp	#'x
    108  c0f9		       d0 04		      bne	.not_x_addr
    109  c0fb		       20 98 c2 	      jsr	monitor_examine_addr_range
    110  c0fe		       60		      rts
    111  c0ff
    112  c0ff				   .not_x_addr
    113  c0ff		       c9 72		      cmp	#'r
    114  c101		       d0 04		      bne	.not_run
    115  c103		       20 cb c3 	      jsr	monitor_run
    116  c106		       60		      rts
    117  c107
    118  c107				   .not_run
      0  c107					      uarta_puts	monitorUnknownText
      1  c107		       a9 1a		      lda	#<[monitorUnknownText]
      2  c109		       85 00		      sta	$0
      3  c10b		       a9 c4		      lda	#>[monitorUnknownText]
      4  c10d		       85 01		      sta	$1
      5  c10f		       20 5b c0 	      jsr	uarta_puts_impl
      0  c112					      uarta_puts	M_STR_BASE
      1  c112		       a9 80		      lda	#<[M_STR_BASE]
      2  c114		       85 00		      sta	$0
      3  c116		       a9 00		      lda	#>[M_STR_BASE]
      4  c118		       85 01		      sta	$1
      5  c11a		       20 5b c0 	      jsr	uarta_puts_impl
    121  c11d		       a9 0a		      lda	#$0A
      0  c11f					      uarta_putb
      1  c11f		       8d 03 02 	      sta	DUART_TX_A
    123  c122		       60		      rts
    124  c123
    125  c123							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    126  c123							;
    127  c123							; monitor_parse_ihex
    128  c123							;
    129  c123							; Parses Intel HEX records
    130  c123							;
    131  c123							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    132  c123
    133  c123				   monitor_parse_ihex subroutine
    134  c123							; Parse Intel HEX format string
    135  c123
    136  c123							; Check that command is long enough to include record and checksum
    137  c123		       a5 10		      lda	M_STR_LEN
    138  c125		       c9 0b		      cmp	#$0B	; Check that it's at least 11 bytes long
    139  c127		       b0 03		      bcs	.check_record_length
    140  c129		       4c 1b c2 	      jmp	invalid_intel_hex
    141  c12c
    142  c12c				   .check_record_length
    143  c12c							; Get the number of data bytes in the record (01-02) and check that the input is
    144  c12c							; long enough
    145  c12c
      0  c12c					      hex_byte_string_to_num	M_STR_BASE + 1, invalid_intel_hex
      1  c12c
      2  c12c		       a5 81		      lda	M_STR_BASE + 1
      3  c12e		       20 38 c0 	      jsr	is_hex
      4  c131		       d0 1e		      bne	.not_hex_string
      5  c133		       a5 81		      lda	M_STR_BASE + 1
      6  c135		       20 51 c0 	      jsr	hex_to_nibble
      7  c138		       18		      clc
      8  c139		       2a		      rol
      9  c13a		       2a		      rol
     10  c13b		       2a		      rol
     11  c13c		       2a		      rol
     12  c13d		       85 00		      sta	$0
     13  c13f
     14  c13f
     15  c13f		       a5 82		      lda	M_STR_BASE + 1 + 1
     16  c141		       20 38 c0 	      jsr	is_hex
     17  c144		       d0 0b		      bne	.not_hex_string
     18  c146		       a5 82		      lda	M_STR_BASE + 1 + 1
     19  c148		       20 51 c0 	      jsr	hex_to_nibble
     20  c14b		       18		      clc
     21  c14c		       05 00		      ora	$0
     22  c14e
     23  c14e		       4c 54 c1 	      jmp	.done_hex
     24  c151
     25  c151				   .not_hex_string
     26  c151		       4c 1b c2 	      jmp	invalid_intel_hex
     27  c154
     28  c154				   .done_hex
     29  c154
    147  c154		       18		      clc
    148  c155		       85 11		      sta	M_HEX_RECORD_LEN
    149  c157		       2a		      rol
    150  c158		       69 0b		      adc	#$0B	; The record should be (data length << 1) + 11 bytes long
    151  c15a		       c5 10		      cmp	M_STR_LEN
    152  c15c		       f0 03		      beq	.check_type
    153  c15e		       4c 1b c2 	      jmp	invalid_intel_hex
    154  c161
    155  c161				   .check_type
      0  c161					      hex_byte_string_to_num	M_STR_BASE + 7, invalid_intel_hex
      1  c161
      2  c161		       a5 87		      lda	M_STR_BASE + 7
      3  c163		       20 38 c0 	      jsr	is_hex
      4  c166		       d0 1e		      bne	.not_hex_string
      5  c168		       a5 87		      lda	M_STR_BASE + 7
      6  c16a		       20 51 c0 	      jsr	hex_to_nibble
      7  c16d		       18		      clc
      8  c16e		       2a		      rol
      9  c16f		       2a		      rol
     10  c170		       2a		      rol
     11  c171		       2a		      rol
     12  c172		       85 00		      sta	$0
     13  c174
     14  c174
     15  c174		       a5 88		      lda	M_STR_BASE + 7 + 1
     16  c176		       20 38 c0 	      jsr	is_hex
     17  c179		       d0 0b		      bne	.not_hex_string
     18  c17b		       a5 88		      lda	M_STR_BASE + 7 + 1
     19  c17d		       20 51 c0 	      jsr	hex_to_nibble
     20  c180		       18		      clc
     21  c181		       05 00		      ora	$0
     22  c183
     23  c183		       4c 89 c1 	      jmp	.done_hex
     24  c186
     25  c186				   .not_hex_string
     26  c186		       4c 1b c2 	      jmp	invalid_intel_hex
     27  c189
     28  c189				   .done_hex
     29  c189
    157  c189		       f0 08		      beq	.data_record
    158  c18b
    159  c18b		       c9 01		      cmp	#01
    160  c18d		       d0 01		      bne	.unsupported_record
    161  c18f		       60		      rts		; Ignore EOF ($0) records
    162  c190
    163  c190				   .unsupported_record
    164  c190		       4c 27 c2 	      jmp	invalid_type_intel_hex
    165  c193
    166  c193				   .data_record
    167  c193							; Get address of data record
      0  c193					      hex_byte_string_to_num	M_STR_BASE + 3, invalid_intel_hex	; High byte
      1  c193
      2  c193		       a5 83		      lda	M_STR_BASE + 3
      3  c195		       20 38 c0 	      jsr	is_hex
      4  c198		       d0 1e		      bne	.not_hex_string
      5  c19a		       a5 83		      lda	M_STR_BASE + 3
      6  c19c		       20 51 c0 	      jsr	hex_to_nibble
      7  c19f		       18		      clc
      8  c1a0		       2a		      rol
      9  c1a1		       2a		      rol
     10  c1a2		       2a		      rol
     11  c1a3		       2a		      rol
     12  c1a4		       85 00		      sta	$0
     13  c1a6
     14  c1a6
     15  c1a6		       a5 84		      lda	M_STR_BASE + 3 + 1
     16  c1a8		       20 38 c0 	      jsr	is_hex
     17  c1ab		       d0 0b		      bne	.not_hex_string
     18  c1ad		       a5 84		      lda	M_STR_BASE + 3 + 1
     19  c1af		       20 51 c0 	      jsr	hex_to_nibble
     20  c1b2		       18		      clc
     21  c1b3		       05 00		      ora	$0
     22  c1b5
     23  c1b5		       4c bb c1 	      jmp	.done_hex
     24  c1b8
     25  c1b8				   .not_hex_string
     26  c1b8		       4c 1b c2 	      jmp	invalid_intel_hex
     27  c1bb
     28  c1bb				   .done_hex
     29  c1bb
    169  c1bb		       85 13		      sta	M_HEX_RECORD_ADDR + 1
      0  c1bd					      hex_byte_string_to_num	M_STR_BASE + 5, invalid_intel_hex	; Low byte
      1  c1bd
      2  c1bd		       a5 85		      lda	M_STR_BASE + 5
      3  c1bf		       20 38 c0 	      jsr	is_hex
      4  c1c2		       d0 1e		      bne	.not_hex_string
      5  c1c4		       a5 85		      lda	M_STR_BASE + 5
      6  c1c6		       20 51 c0 	      jsr	hex_to_nibble
      7  c1c9		       18		      clc
      8  c1ca		       2a		      rol
      9  c1cb		       2a		      rol
     10  c1cc		       2a		      rol
     11  c1cd		       2a		      rol
     12  c1ce		       85 00		      sta	$0
     13  c1d0
     14  c1d0
     15  c1d0		       a5 86		      lda	M_STR_BASE + 5 + 1
     16  c1d2		       20 38 c0 	      jsr	is_hex
     17  c1d5		       d0 0b		      bne	.not_hex_string
     18  c1d7		       a5 86		      lda	M_STR_BASE + 5 + 1
     19  c1d9		       20 51 c0 	      jsr	hex_to_nibble
     20  c1dc		       18		      clc
     21  c1dd		       05 00		      ora	$0
     22  c1df
     23  c1df		       4c e5 c1 	      jmp	.done_hex
     24  c1e2
     25  c1e2				   .not_hex_string
     26  c1e2		       4c 1b c2 	      jmp	invalid_intel_hex
     27  c1e5
     28  c1e5				   .done_hex
     29  c1e5
    171  c1e5		       85 12		      sta	M_HEX_RECORD_ADDR
    172  c1e7
    173  c1e7							; Check record integrity
    174  c1e7		       a0 00		      ldy	#$0
    175  c1e9
    176  c1e9				   .check_record_loop
    177  c1e9		       b9 89 00 	      lda	M_STR_BASE + 9,y
    178  c1ec		       20 38 c0 	      jsr	is_hex
    179  c1ef		       f0 03		      beq	.record_char_is_hex
    180  c1f1		       4c 1b c2 	      jmp	invalid_intel_hex
    181  c1f4
    182  c1f4				   .record_char_is_hex
    183  c1f4		       c8		      iny
    184  c1f5		       c4 11		      cpy	M_HEX_RECORD_LEN
    185  c1f7		       d0 f0		      bne	.check_record_loop
    186  c1f9
    187  c1f9							; Write bytes to memory
    188  c1f9		       a0 00		      ldy	#$0
    189  c1fb		       a2 00		      ldx	#$0
    190  c1fd
    191  c1fd				   .data_write_loop
    192  c1fd		       b5 89		      lda	M_STR_BASE + 9,x
    193  c1ff		       20 51 c0 	      jsr	hex_to_nibble
    194  c202		       18		      clc
    195  c203		       2a		      rol
    196  c204		       2a		      rol
    197  c205		       2a		      rol
    198  c206		       2a		      rol
    199  c207		       85 00		      sta	$0
    200  c209		       e8		      inx
    201  c20a		       b5 89		      lda	M_STR_BASE + 9,x
    202  c20c		       20 51 c0 	      jsr	hex_to_nibble
    203  c20f		       18		      clc
    204  c210		       05 00		      ora	$0
    205  c212		       91 12		      sta	(M_HEX_RECORD_ADDR),y	; Store byte to address
    206  c214		       e8		      inx
    207  c215		       c8		      iny
    208  c216		       c4 11		      cpy	M_HEX_RECORD_LEN
    209  c218		       d0 e3		      bne	.data_write_loop
    210  c21a
    211  c21a							; Done writing!
    212  c21a		       60		      rts
    213  c21b
    214  c21b
    215  c21b				   invalid_intel_hex
      0  c21b					      uarta_puts	monitorIntelHexInvalid
      1  c21b		       a9 3c		      lda	#<[monitorIntelHexInvalid]
      2  c21d		       85 00		      sta	$0
      3  c21f		       a9 c4		      lda	#>[monitorIntelHexInvalid]
      4  c221		       85 01		      sta	$1
      5  c223		       20 5b c0 	      jsr	uarta_puts_impl
    217  c226		       60		      rts
    218  c227
    219  c227				   invalid_type_intel_hex
      0  c227					      uarta_puts	monitorIntelHexInvalidType
      1  c227		       a9 56		      lda	#<[monitorIntelHexInvalidType]
      2  c229		       85 00		      sta	$0
      3  c22b		       a9 c4		      lda	#>[monitorIntelHexInvalidType]
      4  c22d		       85 01		      sta	$1
      5  c22f		       20 5b c0 	      jsr	uarta_puts_impl
    221  c232		       60		      rts
    222  c233
    223  c233							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    224  c233							;
    225  c233							; monitor_change_address
    226  c233							; Changes the current address
    227  c233							;
    228  c233							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    229  c233
    230  c233				   monitor_current_address subroutine
    231  c233							; Check command length
    232  c233		       a5 10		      lda	M_STR_LEN
    233  c235		       c9 05		      cmp	#$5
    234  c237		       f0 03		      beq	.length_valid
    235  c239		       4c d6 c3 	      jmp	monitor_invalid_syntax
    236  c23c
    237  c23c				   .length_valid
      0  c23c					      hex_byte_string_to_num	M_STR_BASE + 1, monitor_invalid_syntax
      1  c23c
      2  c23c		       a5 81		      lda	M_STR_BASE + 1
      3  c23e		       20 38 c0 	      jsr	is_hex
      4  c241		       d0 1e		      bne	.not_hex_string
      5  c243		       a5 81		      lda	M_STR_BASE + 1
      6  c245		       20 51 c0 	      jsr	hex_to_nibble
      7  c248		       18		      clc
      8  c249		       2a		      rol
      9  c24a		       2a		      rol
     10  c24b		       2a		      rol
     11  c24c		       2a		      rol
     12  c24d		       85 00		      sta	$0
     13  c24f
     14  c24f
     15  c24f		       a5 82		      lda	M_STR_BASE + 1 + 1
     16  c251		       20 38 c0 	      jsr	is_hex
     17  c254		       d0 0b		      bne	.not_hex_string
     18  c256		       a5 82		      lda	M_STR_BASE + 1 + 1
     19  c258		       20 51 c0 	      jsr	hex_to_nibble
     20  c25b		       18		      clc
     21  c25c		       05 00		      ora	$0
     22  c25e
     23  c25e		       4c 64 c2 	      jmp	.done_hex
     24  c261
     25  c261				   .not_hex_string
     26  c261		       4c d6 c3 	      jmp	monitor_invalid_syntax
     27  c264
     28  c264				   .done_hex
     29  c264
    239  c264		       85 15		      sta	M_TEMP_ADDR + 1
      0  c266					      hex_byte_string_to_num	M_STR_BASE + 3, monitor_invalid_syntax
      1  c266
      2  c266		       a5 83		      lda	M_STR_BASE + 3
      3  c268		       20 38 c0 	      jsr	is_hex
      4  c26b		       d0 1e		      bne	.not_hex_string
      5  c26d		       a5 83		      lda	M_STR_BASE + 3
      6  c26f		       20 51 c0 	      jsr	hex_to_nibble
      7  c272		       18		      clc
      8  c273		       2a		      rol
      9  c274		       2a		      rol
     10  c275		       2a		      rol
     11  c276		       2a		      rol
     12  c277		       85 00		      sta	$0
     13  c279
     14  c279
     15  c279		       a5 84		      lda	M_STR_BASE + 3 + 1
     16  c27b		       20 38 c0 	      jsr	is_hex
     17  c27e		       d0 0b		      bne	.not_hex_string
     18  c280		       a5 84		      lda	M_STR_BASE + 3 + 1
     19  c282		       20 51 c0 	      jsr	hex_to_nibble
     20  c285		       18		      clc
     21  c286		       05 00		      ora	$0
     22  c288
     23  c288		       4c 8e c2 	      jmp	.done_hex
     24  c28b
     25  c28b				   .not_hex_string
     26  c28b		       4c d6 c3 	      jmp	monitor_invalid_syntax
     27  c28e
     28  c28e				   .done_hex
     29  c28e
    241  c28e		       85 16		      sta	M_CURRENT_ADDR
    242  c290		       a5 15		      lda	M_TEMP_ADDR + 1
    243  c292		       85 17		      sta	M_CURRENT_ADDR + 1
    244  c294
    245  c294		       20 89 c3 	      jsr	monitor_print_address_contents
    246  c297		       60		      rts
    247  c298
    248  c298
    249  c298							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    250  c298							;
    251  c298							; monitor_examine_addr_range
    252  c298							; Examines a range of addresses
    253  c298							; xXXXX.XX
    254  c298							;
    255  c298							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    256  c298
    257  c298				   monitor_examine_addr_range subroutine
    258  c298							; Check command length
    259  c298		       a5 10		      lda	M_STR_LEN
    260  c29a		       c9 08		      cmp	#$8
    261  c29c		       f0 03		      beq	.length_valid
    262  c29e		       4c d6 c3 	      jmp	monitor_invalid_syntax
    263  c2a1
    264  c2a1				   .length_valid
    265  c2a1							; Get start address
      0  c2a1					      hex_byte_string_to_num	M_STR_BASE + 1, monitor_invalid_syntax
      1  c2a1
      2  c2a1		       a5 81		      lda	M_STR_BASE + 1
      3  c2a3		       20 38 c0 	      jsr	is_hex
      4  c2a6		       d0 1e		      bne	.not_hex_string
      5  c2a8		       a5 81		      lda	M_STR_BASE + 1
      6  c2aa		       20 51 c0 	      jsr	hex_to_nibble
      7  c2ad		       18		      clc
      8  c2ae		       2a		      rol
      9  c2af		       2a		      rol
     10  c2b0		       2a		      rol
     11  c2b1		       2a		      rol
     12  c2b2		       85 00		      sta	$0
     13  c2b4
     14  c2b4
     15  c2b4		       a5 82		      lda	M_STR_BASE + 1 + 1
     16  c2b6		       20 38 c0 	      jsr	is_hex
     17  c2b9		       d0 0b		      bne	.not_hex_string
     18  c2bb		       a5 82		      lda	M_STR_BASE + 1 + 1
     19  c2bd		       20 51 c0 	      jsr	hex_to_nibble
     20  c2c0		       18		      clc
     21  c2c1		       05 00		      ora	$0
     22  c2c3
     23  c2c3		       4c c9 c2 	      jmp	.done_hex
     24  c2c6
     25  c2c6				   .not_hex_string
     26  c2c6		       4c d6 c3 	      jmp	monitor_invalid_syntax
     27  c2c9
     28  c2c9				   .done_hex
     29  c2c9
    267  c2c9		       85 15		      sta	M_TEMP_ADDR + 1
      0  c2cb					      hex_byte_string_to_num	M_STR_BASE + 3, monitor_invalid_syntax
      1  c2cb
      2  c2cb		       a5 83		      lda	M_STR_BASE + 3
      3  c2cd		       20 38 c0 	      jsr	is_hex
      4  c2d0		       d0 1e		      bne	.not_hex_string
      5  c2d2		       a5 83		      lda	M_STR_BASE + 3
      6  c2d4		       20 51 c0 	      jsr	hex_to_nibble
      7  c2d7		       18		      clc
      8  c2d8		       2a		      rol
      9  c2d9		       2a		      rol
     10  c2da		       2a		      rol
     11  c2db		       2a		      rol
     12  c2dc		       85 00		      sta	$0
     13  c2de
     14  c2de
     15  c2de		       a5 84		      lda	M_STR_BASE + 3 + 1
     16  c2e0		       20 38 c0 	      jsr	is_hex
     17  c2e3		       d0 0b		      bne	.not_hex_string
     18  c2e5		       a5 84		      lda	M_STR_BASE + 3 + 1
     19  c2e7		       20 51 c0 	      jsr	hex_to_nibble
     20  c2ea		       18		      clc
     21  c2eb		       05 00		      ora	$0
     22  c2ed
     23  c2ed		       4c f3 c2 	      jmp	.done_hex
     24  c2f0
     25  c2f0				   .not_hex_string
     26  c2f0		       4c d6 c3 	      jmp	monitor_invalid_syntax
     27  c2f3
     28  c2f3				   .done_hex
     29  c2f3
    269  c2f3		       85 14		      sta	M_TEMP_ADDR
    270  c2f5
    271  c2f5							; Get length
      0  c2f5					      hex_byte_string_to_num	M_STR_BASE + 6, monitor_invalid_syntax
      1  c2f5
      2  c2f5		       a5 86		      lda	M_STR_BASE + 6
      3  c2f7		       20 38 c0 	      jsr	is_hex
      4  c2fa		       d0 1e		      bne	.not_hex_string
      5  c2fc		       a5 86		      lda	M_STR_BASE + 6
      6  c2fe		       20 51 c0 	      jsr	hex_to_nibble
      7  c301		       18		      clc
      8  c302		       2a		      rol
      9  c303		       2a		      rol
     10  c304		       2a		      rol
     11  c305		       2a		      rol
     12  c306		       85 00		      sta	$0
     13  c308
     14  c308
     15  c308		       a5 87		      lda	M_STR_BASE + 6 + 1
     16  c30a		       20 38 c0 	      jsr	is_hex
     17  c30d		       d0 0b		      bne	.not_hex_string
     18  c30f		       a5 87		      lda	M_STR_BASE + 6 + 1
     19  c311		       20 51 c0 	      jsr	hex_to_nibble
     20  c314		       18		      clc
     21  c315		       05 00		      ora	$0
     22  c317
     23  c317		       4c 1d c3 	      jmp	.done_hex
     24  c31a
     25  c31a				   .not_hex_string
     26  c31a		       4c d6 c3 	      jmp	monitor_invalid_syntax
     27  c31d
     28  c31d				   .done_hex
     29  c31d
    273  c31d		       85 06		      sta	$6
    274  c31f
    275  c31f		       a2 00		      ldx	#$0
    276  c321		       a0 00		      ldy	#$0
    277  c323
    278  c323				   .print_line
    279  c323							; Print start address
    280  c323		       a5 15		      lda	M_TEMP_ADDR + 1
    281  c325		       20 1f c0 	      jsr	num_to_hex_string
    282  c328		       a5 00		      lda	$0
      0  c32a					      uarta_putb
      1  c32a		       8d 03 02 	      sta	DUART_TX_A
    284  c32d		       a5 01		      lda	$1
      0  c32f					      uarta_putb
      1  c32f		       8d 03 02 	      sta	DUART_TX_A
    286  c332		       a5 14		      lda	M_TEMP_ADDR
    287  c334		       20 1f c0 	      jsr	num_to_hex_string
    288  c337		       a5 00		      lda	$0
      0  c339					      uarta_putb
      1  c339		       8d 03 02 	      sta	DUART_TX_A
    290  c33c		       a5 01		      lda	$1
      0  c33e					      uarta_putb
      1  c33e		       8d 03 02 	      sta	DUART_TX_A
    292  c341
    293  c341		       a9 3a		      lda	#':
      0  c343					      uarta_putb
      1  c343		       8d 03 02 	      sta	DUART_TX_A
    295  c346		       a9 20		      lda	#$20
      0  c348					      uarta_putb
      1  c348		       8d 03 02 	      sta	DUART_TX_A
    297  c34b
    298  c34b				   .print_char
    299  c34b		       b1 14		      lda	(M_TEMP_ADDR),y
    300  c34d		       20 1f c0 	      jsr	num_to_hex_string
    301  c350		       a5 00		      lda	$0
      0  c352					      uarta_putb
      1  c352		       8d 03 02 	      sta	DUART_TX_A
    303  c355		       a5 01		      lda	$1
      0  c357					      uarta_putb
      1  c357		       8d 03 02 	      sta	DUART_TX_A
    305  c35a		       a9 20		      lda	#$20
      0  c35c					      uarta_putb
      1  c35c		       8d 03 02 	      sta	DUART_TX_A
    307  c35f		       c8		      iny
    308  c360		       e8		      inx
    309  c361		       e4 06		      cpx	$6	; Have all bytes been printed?
    310  c363		       f0 1b		      beq	.print_done
    311  c365		       c0 10		      cpy	#$10	; Have all bytes on this line been printed?
    312  c367		       d0 e2		      bne	.print_char
    313  c369		       a0 00		      ldy	#$0
    314  c36b
    315  c36b							; Increment stored address
    316  c36b		       18		      clc
    317  c36c		       a5 14		      lda	M_TEMP_ADDR
    318  c36e		       69 10		      adc	#$10
    319  c370		       85 14		      sta	M_TEMP_ADDR
    320  c372		       a5 15		      lda	M_TEMP_ADDR + 1
    321  c374		       69 00		      adc	#$0
    322  c376		       85 15		      sta	M_TEMP_ADDR + 1
    323  c378
    324  c378		       a9 0a		      lda	#$0A
      0  c37a					      uarta_putb
      1  c37a		       8d 03 02 	      sta	DUART_TX_A
    326  c37d		       4c 23 c3 	      jmp	.print_line
    327  c380
    328  c380				   .print_done
    329  c380		       a9 0a		      lda	#$0A
      0  c382					      uarta_putb
      1  c382		       8d 03 02 	      sta	DUART_TX_A
      0  c385					      uarta_putb
      1  c385		       8d 03 02 	      sta	DUART_TX_A
    332  c388		       60		      rts
    333  c389
    334  c389				   monitor_print_address_contents subroutine
    335  c389							; Print address
    336  c389		       a5 17		      lda	M_CURRENT_ADDR + 1
    337  c38b		       20 1f c0 	      jsr	num_to_hex_string
    338  c38e		       a5 00		      lda	$0
      0  c390					      uarta_putb
      1  c390		       8d 03 02 	      sta	DUART_TX_A
    340  c393		       a5 01		      lda	$1
      0  c395					      uarta_putb
      1  c395		       8d 03 02 	      sta	DUART_TX_A
    342  c398
    343  c398		       a5 16		      lda	M_CURRENT_ADDR + 0
    344  c39a		       20 1f c0 	      jsr	num_to_hex_string
    345  c39d		       a5 00		      lda	$0
      0  c39f					      uarta_putb
      1  c39f		       8d 03 02 	      sta	DUART_TX_A
    347  c3a2		       a5 01		      lda	$1
      0  c3a4					      uarta_putb
      1  c3a4		       8d 03 02 	      sta	DUART_TX_A
    349  c3a7
    350  c3a7		       a9 3a		      lda	#':
      0  c3a9					      uarta_putb
      1  c3a9		       8d 03 02 	      sta	DUART_TX_A
    352  c3ac		       a9 20		      lda	#$20
      0  c3ae					      uarta_putb
      1  c3ae		       8d 03 02 	      sta	DUART_TX_A
    354  c3b1
    355  c3b1							; Print data
    356  c3b1		       a0 00		      ldy	#$0
    357  c3b3		       b1 16		      lda	(M_CURRENT_ADDR),y
    358  c3b5		       20 1f c0 	      jsr	num_to_hex_string
    359  c3b8		       a5 00		      lda	$0
      0  c3ba					      uarta_putb
      1  c3ba		       8d 03 02 	      sta	DUART_TX_A
    361  c3bd		       a5 01		      lda	$1
      0  c3bf					      uarta_putb
      1  c3bf		       8d 03 02 	      sta	DUART_TX_A
    363  c3c2
    364  c3c2		       a9 0a		      lda	#$0A
      0  c3c4					      uarta_putb
      1  c3c4		       8d 03 02 	      sta	DUART_TX_A
      0  c3c7					      uarta_putb
      1  c3c7		       8d 03 02 	      sta	DUART_TX_A
    367  c3ca		       60		      rts
    368  c3cb
    369  c3cb				   monitor_run subroutine
    370  c3cb		       a9 c3		      lda	#>[.run_done]
    371  c3cd		       48		      pha
    372  c3ce		       a9 d4		      lda	#<[.run_done]
    373  c3d0		       48		      pha
    374  c3d1		       6c 16 00 	      jmp	(M_CURRENT_ADDR)
    375  c3d4
    376  c3d4				   .run_done
    377  c3d4		       ea		      nop
    378  c3d5		       60		      rts
    379  c3d6
    380  c3d6
    381  c3d6				   monitor_invalid_syntax
      0  c3d6					      uarta_puts	monitorInvalidSyntaxText
      1  c3d6		       a9 2c		      lda	#<[monitorInvalidSyntaxText]
      2  c3d8		       85 00		      sta	$0
      3  c3da		       a9 c4		      lda	#>[monitorInvalidSyntaxText]
      4  c3dc		       85 01		      sta	$1
      5  c3de		       20 5b c0 	      jsr	uarta_puts_impl
    383  c3e1		       60		      rts
    384  c3e2
    385  c3e2
    386  c3e2							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    387  c3e2							;
    388  c3e2							; Strings
    389  c3e2							;
    390  c3e2							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    391  c3e2
    392  c3e2		       47 6f 74 20*gotStrText .byte.b	"Got string: ", $0
    393  c3ef
    394  c3ef		       47 72 69 66*monitorInfoText .byte.b	"Grif65 monitor v0.1 by Andy Best", $0A, $0
    395  c411		       4c 65 6e 67*monitorLengthText .byte.b	"Length: ", $0
    396  c41a		       55 6e 6b 6e*monitorUnknownText .byte.b	"Unknown command: ", $0
    397  c42c		       49 6e 76 61*monitorInvalidSyntaxText .byte.b	"Invalid syntax", $0A, $0
    398  c43c
    399  c43c		       49 6e 76 61*monitorIntelHexInvalid .byte.b	"Invalid Intel Hex Record", $0A, $0
    400  c456		       49 6e 76 61*monitorIntelHexInvalidType .byte.b	"Invalid record type. Valid types are 00 (data) and 01 (EOF)", $0A, $0
    401  c493
    402  c493				   monitorHelpText
    403  c493		       0a		      .byte.b	$0A
    404  c494		       43 6f 6d 6d*	      .byte.b	"Commands:", $0A
    405  c49e		       20 20 3f 20*	      .byte.b	"  ? - Help", $0A
    406  c4a9		       20 20 61 20*	      .byte.b	"  a - Set address [aXXXX]", $0A
    407  c4c3		       20 20 78 20*	      .byte.b	"  x - Examine address [xXXXX.CC] (XXXX- addr, CC- num bytes)", $0A
    408  c500		       0a 20 20 49*	      .byte.b	$0A, "  Intel HEX Syntax:", $0A
    409  c515		       20 20 20 20*	      .byte.b	"    :[record size][address][record type][bytes][checksum]", $0A
    410  c54f		       0a 00		      .byte.b	$0A, $0
------- FILE main.dasm
     19  c551
     20  c551
     21  c551							; Interrupts
     22  fffa					      org	$FFFA
     23  fffa		       00 c0		      .WORD.w	nmiHandler
     24  fffc		       03 c0		      .WORD.w	resetHandler
     25  fffe		       00 c0		      .WORD.w	irqHandler
