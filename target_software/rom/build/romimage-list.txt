------- FILE main.dasm LEVEL 1 PASS 2
      1  10000 ????						; vim: setlocal ft=asmM6502:
      2  10000 ????
      3  10000 ????				       processor	6502
      4  10000 ????
      5  10000 ????
      6  10000 ????
      7  c000					      org	$C000
      8  c000				   irqHandler
      9  c000				   nmiHandler
     10  c000		       4c 00 c0 	      jmp	*
     11  c003
     12  c003				   resetHandler
     13  c003		       20 65 c0 	      jsr	start_monitor
     14  c006		       4c 06 c0 	      jmp	*	; Shouldn't reach here.
     15  c009
------- FILE utils.dasm LEVEL 2 PASS 2
      0  c009					      include	"utils.dasm"
      1  c009					      processor	6502
      2  c009
      3  c009					      mac	strlen
      4  c009					      lda	#<[{1}]	; Store the address of the string at $0000
      5  c009					      sta	$0
      6  c009					      lda	#>[{1}]
      7  c009					      sta	$1
      8  c009					      jsr	strlen_impl
      9  c009					      endm
     10  c009
     11  c009					      mac	strlen_indir
     12  c009					      lda	{1}	; Store the address of the string at $0000
     13  c009					      sta	$0
     14  c009					      lda	{1} + 1
     15  c009					      sta	$1
     16  c009					      jsr	strlen_impl
     17  c009					      endm
     18  c009
     19  c009				   strlen_impl subroutine		; Stores length of string in acc
     20  c009		       a0 00		      ldy	#0
     21  c00b				   .strlen_loop
     22  c00b		       b1 00		      lda	($0),y
     23  c00d		       f0 04		      beq	.strlen_done
     24  c00f		       c8		      iny
     25  c010		       4c 0b c0 	      jmp	.strlen_loop
     26  c013				   .strlen_done
     27  c013		       98		      tya
     28  c014		       60		      rts
     29  c015
     30  c015				   nibble_to_hex subroutine
     31  c015		       c9 0a		      cmp	#$A
     32  c017		       b0 03		      bcs	.gt_9
     33  c019		       69 30		      adc	#$30	; 0-9, so offset to 0
     34  c01b		       60		      rts
     35  c01c
     36  c01c				   .gt_9		; Greater than 9, so we need to offset to A - 10
     37  c01c		       69 36		      adc	#$36
     38  c01e		       60		      rts
     39  c01f
     40  c01f				   num_to_hex_string subroutine		; Convert num in acc to hex. Stores in $00-$01
     41  c01f		       48		      pha
     42  c020		       29 f0		      and	#$F0
     43  c022		       4a		      lsr
     44  c023		       4a		      lsr
     45  c024		       4a		      lsr
     46  c025		       4a		      lsr
     47  c026		       20 15 c0 	      jsr	nibble_to_hex
     48  c029		       85 00		      sta	$00
     49  c02b		       68		      pla
     50  c02c		       29 0f		      and	#$0F
     51  c02e		       20 15 c0 	      jsr	nibble_to_hex
     52  c031		       85 01		      sta	$01
     53  c033		       60		      rts
     54  c034
     55  c034				   is_hex     subroutine		; Checks if ASCII value in acc is a hex digit
     56  c034		       c9 30		      cmp	#$30
     57  c036		       90 12		      bcc	.not_hex
     58  c038		       c9 3a		      cmp	#$3A
     59  c03a		       b0 03		      bcs	.not_a_number
     60  c03c		       a9 01		      lda	#$1
     61  c03e		       60		      rts
     62  c03f				   .not_a_number
     63  c03f		       c9 41		      cmp	#$41
     64  c041		       90 07		      bcc	.not_hex
     65  c043		       c9 47		      cmp	#$47
     66  c045		       b0 03		      bcs	.not_hex
     67  c047		       a9 01		      lda	#$1
     68  c049		       60		      rts
     69  c04a				   .not_hex
     70  c04a		       a9 00		      lda	#$0
     71  c04c		       60		      rts
     72  c04d
     73  c04d				   hex_to_nibble subroutine		; Convert ascii hex to nibble
     74  c04d		       c9 39		      cmp	#$39	; Is it a letter? (A-F)
     75  c04f		       b0 03		      bcs	.letter
     76  c051		       e9 30		      sbc	#$30
     77  c053		       60		      rts
     78  c054				   .letter
     79  c054		       e9 37		      sbc	#$37
     80  c056		       60		      rts
     81  c057
------- FILE main.dasm
------- FILE uart.dasm LEVEL 2 PASS 2
      0  c057					      include	"uart.dasm"
      1  c057							; vim: setlocal ft=asmM6502:
      2  c057
      3  c057					      processor	6502
      4  c057
      5  c057							; UART Register locations
      6  c057		       02 00	   DUART_BASE equ	$0200
      7  c057		       02 03	   DUART_TX_A equ	DUART_BASE + 3
      8  c057		       02 03	   DUART_RX_A equ	DUART_BASE + 3
      9  c057
     10  c057		       02 01	   DUART_STATUS_A equ	DUART_BASE + 1
     11  c057
     12  c057					      mac	uarta_puts
     13  c057					      lda	#<[{1}]	; Store the address of the string at $0000
     14  c057					      sta	$0
     15  c057					      lda	#>[{1}]
     16  c057					      sta	$1
     17  c057					      jsr	uarta_puts_impl
     18  c057					      endm
     19  c057
     20  c057					      mac	uarta_puts_indir
     21  c057					      lda	{1}	; Store the pointer to the string at $0000
     22  c057					      sta	$0
     23  c057					      lda	{1}+1
     24  c057					      sta	$1
     25  c057					      jsr	uarta_puts_impl
     26  c057					      endm
     27  c057
     28  c057				   uarta_puts_impl subroutine
     29  c057		       a0 00		      ldy	#0
     30  c059				   .uarta_puts_loop
     31  c059		       b1 00		      lda	($0),y
     32  c05b		       f0 07		      beq	.uarta_puts_done
     33  c05d		       8d 03 02 	      sta	DUART_TX_A
     34  c060		       c8		      iny
     35  c061		       4c 59 c0 	      jmp	.uarta_puts_loop
     36  c064				   .uarta_puts_done
     37  c064		       60		      rts
     38  c065
     39  c065
     40  c065					      mac	uarta_putb
     41  c065					      sta	DUART_TX_A
     42  c065					      endm
     43  c065
     44  c065
     45  c065					      mac	uarta_getb
     46  c065					      lda	DUART_RX_A
     47  c065					      endm
     48  c065
     49  c065
     50  c065					      mac	uarta_bytes_available
     51  c065					      lda	#$01	; Perform a bit test on the RX_RDY bit in status reg
     52  c065					      bit	DUART_STATUS_A
     53  c065					      endm
     54  c065
     55  c065
------- FILE main.dasm
------- FILE monitor.dasm LEVEL 2 PASS 2
      0  c065					      include	"monitor.dasm"
      1  c065
      2  c065					      processor	6502
      3  c065
      4  c065		       00 f0	   M_STR_BASE equ	$F0
      5  c065		       00 10	   M_STR_LEN  equ	$10
      6  c065
      7  c065
      8  c065				   start_monitor subroutine
      0  c065					      uarta_puts	monitorInfoText
      1  c065		       a9 07		      lda	#<[monitorInfoText]
      2  c067		       85 00		      sta	$0
      3  c069		       a9 c1		      lda	#>[monitorInfoText]
      4  c06b		       85 01		      sta	$1
      5  c06d		       20 57 c0 	      jsr	uarta_puts_impl
     10  c070
     11  c070				   .monitor_loop
     12  c070		       a9 24		      lda	#$24	; Write the prompt ('$ ')
      0  c072					      uarta_putb
      1  c072		       8d 03 02 	      sta	DUART_TX_A
     14  c075		       a9 20		      lda	#$20
      0  c077					      uarta_putb
      1  c077		       8d 03 02 	      sta	DUART_TX_A
     16  c07a
     17  c07a		       20 84 c0 	      jsr	monitor_get_string	; Print the string with surrounding quotes
     18  c07d		       20 b9 c0 	      jsr	monitor_parse_command
     19  c080		       4c 70 c0 	      jmp	.monitor_loop
     20  c083		       60		      rts
     21  c084
     22  c084				   monitor_get_string subroutine
     23  c084		       a0 00		      ldy	#$0
     24  c086
     25  c086				   .check_char
      0  c086					      uarta_bytes_available
      1  c086		       a9 01		      lda	#$01
      2  c088		       2c 01 02 	      bit	DUART_STATUS_A
     27  c08b		       f0 15		      beq	.no_char	; No character available
     28  c08d
      0  c08d					      uarta_getb		; Get byte from UART
      1  c08d		       ad 03 02 	      lda	DUART_RX_A
     30  c090
     31  c090		       c9 0a		      cmp	#$0A	; Check if it's a newline
     32  c092		       f0 1c		      beq	.newline
     33  c094		       c9 08		      cmp	#$08	; Check if it's a backspace
     34  c096		       f0 0d		      beq	.backspace
     35  c098
     36  c098				   .store_char
     37  c098		       99 f0 00 	      sta	M_STR_BASE,y
     38  c09b		       c8		      iny
      0  c09c					      uarta_putb
      1  c09c		       8d 03 02 	      sta	DUART_TX_A
     40  c09f		       4c 86 c0 	      jmp	.check_char
     41  c0a2
     42  c0a2				   .no_char
     43  c0a2		       4c 86 c0 	      jmp	.check_char
     44  c0a5
     45  c0a5				   .backspace
     46  c0a5		       c0 00		      cpy	#$0
     47  c0a7		       f0 04		      beq	.backspace_done
     48  c0a9		       88		      dey		; Remove character if y > 0
      0  c0aa					      uarta_putb
      1  c0aa		       8d 03 02 	      sta	DUART_TX_A
     50  c0ad				   .backspace_done
     51  c0ad		       4c 86 c0 	      jmp	.check_char
     52  c0b0
     53  c0b0				   .newline
      0  c0b0					      uarta_putb
      1  c0b0		       8d 03 02 	      sta	DUART_TX_A
     55  c0b3		       a9 00		      lda	#$0
     56  c0b5		       99 f0 00 	      sta	M_STR_BASE,y	; Add null terminator
     57  c0b8		       60		      rts
     58  c0b9
     59  c0b9
     60  c0b9							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     61  c0b9							;
     62  c0b9							; monitor_parse_command
     63  c0b9							;
     64  c0b9							; Parses the command present at MONITOR_STR_BASE
     65  c0b9							;
     66  c0b9							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     67  c0b9
     68  c0b9				   monitor_parse_command subroutine
      0  c0b9					      strlen	M_STR_BASE
      1  c0b9		       a9 f0		      lda	#<[M_STR_BASE]
      2  c0bb		       85 00		      sta	$0
      3  c0bd		       a9 00		      lda	#>[M_STR_BASE]
      4  c0bf		       85 01		      sta	$1
      5  c0c1		       20 09 c0 	      jsr	strlen_impl
     70  c0c4		       85 10		      sta	M_STR_LEN
     71  c0c6
     72  c0c6		       a5 f0		      lda	M_STR_BASE
     73  c0c8
     74  c0c8							; Check if Intel hex (starts with :)
     75  c0c8		       c9 3a		      cmp	#':
     76  c0ca		       d0 04		      bne	.not_iHex
     77  c0cc		       20 dc c0 	      jsr	monitor_parse_ihex
     78  c0cf		       60		      rts
     79  c0d0
     80  c0d0				   .not_iHex
      0  c0d0					      uarta_puts	monitorNotHexText
      1  c0d0		       a9 5e		      lda	#<[monitorNotHexText]
      2  c0d2		       85 00		      sta	$0
      3  c0d4		       a9 c1		      lda	#>[monitorNotHexText]
      4  c0d6		       85 01		      sta	$1
      5  c0d8		       20 57 c0 	      jsr	uarta_puts_impl
     82  c0db		       60		      rts
     83  c0dc
     84  c0dc				   monitor_parse_ihex subroutine
     85  c0dc							; Parse Intel HEX format string
     86  c0dc
     87  c0dc							; Check that command is long enough to include record and checksum
     88  c0dc		       a5 10		      lda	M_STR_LEN
     89  c0de		       c9 0b		      cmp	#$0B	; Check that it's at least 11 bytes long
     90  c0e0		       b0 0c		      bcs	.check_record
      0  c0e2					      uarta_puts	monitorIntelHexInvalid
      1  c0e2		       a9 44		      lda	#<[monitorIntelHexInvalid]
      2  c0e4		       85 00		      sta	$0
      3  c0e6		       a9 c1		      lda	#>[monitorIntelHexInvalid]
      4  c0e8		       85 01		      sta	$1
      5  c0ea		       20 57 c0 	      jsr	uarta_puts_impl
     92  c0ed		       60		      rts
     93  c0ee				   .check_record
     94  c0ee
      0  c0ee					      uarta_puts	monitorIntelHexText
      1  c0ee		       a9 67		      lda	#<[monitorIntelHexText]
      2  c0f0		       85 00		      sta	$0
      3  c0f2		       a9 c1		      lda	#>[monitorIntelHexText]
      4  c0f4		       85 01		      sta	$1
      5  c0f6		       20 57 c0 	      jsr	uarta_puts_impl
     96  c0f9		       60		      rts
     97  c0fa
     98  c0fa		       47 6f 74 20*gotStrText .byte.b	"Got string: ", $0
     99  c107
    100  c107		       47 72 69 66*monitorInfoText .byte.b	"Grif65 monitor v0.1 by Andy Best", $0A, $0
    101  c129		       4c 65 6e 67*monitorLengthText .byte.b	"Length: ", $0
    102  c132		       55 6e 6b 6e*monitorUnknownText .byte.b	"Unknown command: ", $0
    103  c144
    104  c144		       49 6e 76 61*monitorIntelHexInvalid .byte.b	"Invalid Intel Hex Record", $0A, $0
    105  c15e
    106  c15e		       4e 6f 74 20*monitorNotHexText .byte.b	"Not hex", $0A, $0
    107  c167		       49 6e 74 65*monitorIntelHexText .byte.b	"Intel Hex!", $0A, $0
    108  c173		       57 72 6f 6e*monitorWrongNumArgsText .byte.b	"Wrong number of arguments", $0A, $0
    109  c18e		       41 72 67 75*monitorBadArgs .byte.b	"Arguments in invalid format", $0A, $0
    110  c1ab		       41 72 67 75*monitorNotHex .byte.b	"Argument not valid hex", $0A, $0
    111  c1c3
    112  c1c3				   monitorHelpText
    113  c1c3		       0a		      .byte.b	$0A
    114  c1c4		       43 6f 6d 6d*	      .byte.b	"Commands:", $0A
    115  c1ce		       20 20 3f 20*	      .byte.b	"  ? - Help", $0A
    116  c1d9		       20 20 61 20*	      .byte.b	"  a - Set address [a XXXX]", $0A
    117  c1f4		       0a 00		      .byte.b	$0A, $0
------- FILE main.dasm
     19  c1f6
     20  c1f6
     21  c1f6							; Interrupts
     22  fffa					      org	$FFFA
     23  fffa		       00 c0		      .WORD.w	nmiHandler
     24  fffc		       03 c0		      .WORD.w	resetHandler
     25  fffe		       00 c0		      .WORD.w	irqHandler
