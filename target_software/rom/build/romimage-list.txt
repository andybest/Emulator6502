------- FILE main.dasm LEVEL 1 PASS 2
      1  10000 ????						; vim: setlocal ft=asmM6502:
      2  10000 ????
      3  10000 ????				       processor	6502
      4  10000 ????
      5  10000 ????
      6  10000 ????
      7  c000					      org	$C000
      8  c000				   irqHandler
      9  c000				   nmiHandler
     10  c000		       4c 00 c0 	      jmp	*
     11  c003
     12  c003				   resetHandler
     13  c003		       20 65 c0 	      jsr	start_monitor
     14  c006		       4c 06 c0 	      jmp	*	; Shouldn't reach here.
     15  c009
------- FILE utils.dasm LEVEL 2 PASS 2
      0  c009					      include	"utils.dasm"
      1  c009					      processor	6502
      2  c009
      3  c009					      mac	strlen
      4  c009					      lda	#<[{1}]	; Store the address of the string at $0000
      5  c009					      sta	$0
      6  c009					      lda	#>[{1}]
      7  c009					      sta	$1
      8  c009					      jsr	strlen_impl
      9  c009					      endm
     10  c009
     11  c009					      mac	strlen_indir
     12  c009					      lda	{1}	; Store the address of the string at $0000
     13  c009					      sta	$0
     14  c009					      lda	{1} + 1
     15  c009					      sta	$1
     16  c009					      jsr	strlen_impl
     17  c009					      endm
     18  c009
     19  c009				   strlen_impl subroutine		; Stores length of string in acc
     20  c009		       a0 00		      ldy	#0
     21  c00b				   .strlen_loop
     22  c00b		       b1 00		      lda	($0),y
     23  c00d		       f0 04		      beq	.strlen_done
     24  c00f		       c8		      iny
     25  c010		       4c 0b c0 	      jmp	.strlen_loop
     26  c013				   .strlen_done
     27  c013		       98		      tya
     28  c014		       60		      rts
     29  c015
     30  c015				   nibble_to_hex subroutine
     31  c015		       c9 0a		      cmp	#$A
     32  c017		       b0 03		      bcs	.gt_9
     33  c019		       69 30		      adc	#$30	; 0-9, so offset to 0
     34  c01b		       60		      rts
     35  c01c
     36  c01c				   .gt_9		; Greater than 9, so we need to offset to A - 10
     37  c01c		       69 36		      adc	#$36
     38  c01e		       60		      rts
     39  c01f
     40  c01f				   num_to_hex_string subroutine		; Convert num in acc to hex. Stores in $00-$01
     41  c01f		       48		      pha
     42  c020		       29 f0		      and	#$F0
     43  c022		       4a		      lsr
     44  c023		       4a		      lsr
     45  c024		       4a		      lsr
     46  c025		       4a		      lsr
     47  c026		       20 15 c0 	      jsr	nibble_to_hex
     48  c029		       85 00		      sta	$00
     49  c02b		       68		      pla
     50  c02c		       29 0f		      and	#$0F
     51  c02e		       20 15 c0 	      jsr	nibble_to_hex
     52  c031		       85 01		      sta	$01
     53  c033		       60		      rts
     54  c034
     55  c034				   is_hex     subroutine		; Checks if ASCII value in acc is a hex digit
     56  c034		       c9 30		      cmp	#$30
     57  c036		       90 12		      bcc	.not_hex
     58  c038		       c9 3a		      cmp	#$3A
     59  c03a		       b0 03		      bcs	.not_a_number
     60  c03c		       a9 01		      lda	#$1
     61  c03e		       60		      rts
     62  c03f				   .not_a_number
     63  c03f		       c9 41		      cmp	#$41
     64  c041		       90 07		      bcc	.not_hex
     65  c043		       c9 47		      cmp	#$47
     66  c045		       b0 03		      bcs	.not_hex
     67  c047		       a9 01		      lda	#$1
     68  c049		       60		      rts
     69  c04a				   .not_hex
     70  c04a		       a9 00		      lda	#$0
     71  c04c		       60		      rts
     72  c04d
     73  c04d				   hex_to_nibble subroutine		; Convert ascii hex to nibble
     74  c04d		       c9 39		      cmp	#$39	; Is it a letter? (A-F)
     75  c04f		       b0 03		      bcs	.letter
     76  c051		       e9 30		      sbc	#$30
     77  c053		       60		      rts
     78  c054				   .letter
     79  c054		       e9 37		      sbc	#$37
     80  c056		       60		      rts
     81  c057
------- FILE main.dasm
------- FILE uart.dasm LEVEL 2 PASS 2
      0  c057					      include	"uart.dasm"
      1  c057							; vim: setlocal ft=asmM6502:
      2  c057
      3  c057					      processor	6502
      4  c057
      5  c057							; UART Register locations
      6  c057		       02 00	   DUART_BASE equ	$0200
      7  c057		       02 03	   DUART_TX_A equ	DUART_BASE + 3
      8  c057		       02 03	   DUART_RX_A equ	DUART_BASE + 3
      9  c057
     10  c057		       02 01	   DUART_STATUS_A equ	DUART_BASE + 1
     11  c057
     12  c057					      mac	uarta_puts
     13  c057					      lda	#<[{1}]	; Store the address of the string at $0000
     14  c057					      sta	$0
     15  c057					      lda	#>[{1}]
     16  c057					      sta	$1
     17  c057					      jsr	uarta_puts_impl
     18  c057					      endm
     19  c057
     20  c057					      mac	uarta_puts_indir
     21  c057					      lda	{1}	; Store the pointer to the string at $0000
     22  c057					      sta	$0
     23  c057					      lda	{1}+1
     24  c057					      sta	$1
     25  c057					      jsr	uarta_puts_impl
     26  c057					      endm
     27  c057
     28  c057				   uarta_puts_impl subroutine
     29  c057		       a0 00		      ldy	#0
     30  c059				   .uarta_puts_loop
     31  c059		       b1 00		      lda	($0),y
     32  c05b		       f0 07		      beq	.uarta_puts_done
     33  c05d		       8d 03 02 	      sta	DUART_TX_A
     34  c060		       c8		      iny
     35  c061		       4c 59 c0 	      jmp	.uarta_puts_loop
     36  c064				   .uarta_puts_done
     37  c064		       60		      rts
     38  c065
     39  c065
     40  c065					      mac	uarta_putb
     41  c065					      sta	DUART_TX_A
     42  c065					      endm
     43  c065
     44  c065
     45  c065					      mac	uarta_getb
     46  c065					      lda	DUART_RX_A
     47  c065					      endm
     48  c065
     49  c065
     50  c065					      mac	uarta_bytes_available
     51  c065					      lda	#$01	; Perform a bit test on the RX_RDY bit in status reg
     52  c065					      bit	DUART_STATUS_A
     53  c065					      endm
     54  c065
     55  c065
------- FILE main.dasm
------- FILE monitor.dasm LEVEL 2 PASS 2
      0  c065					      include	"monitor.dasm"
      1  c065
      2  c065					      processor	6502
      3  c065
      4  c065		       00 80	   M_STR_BASE equ	$80
      5  c065		       00 10	   M_STR_LEN  equ	$10
      6  c065
      7  c065
      8  c065				   start_monitor subroutine
      0  c065					      uarta_puts	monitorInfoText
      1  c065		       a9 f7		      lda	#<[monitorInfoText]
      2  c067		       85 00		      sta	$0
      3  c069		       a9 c0		      lda	#>[monitorInfoText]
      4  c06b		       85 01		      sta	$1
      5  c06d		       20 57 c0 	      jsr	uarta_puts_impl
     10  c070
     11  c070				   .monitor_loop
     12  c070		       a9 24		      lda	#$24	; Write the prompt ('$ ')
      0  c072					      uarta_putb
      1  c072		       8d 03 02 	      sta	DUART_TX_A
     14  c075		       a9 20		      lda	#$20
      0  c077					      uarta_putb
      1  c077		       8d 03 02 	      sta	DUART_TX_A
     16  c07a
     17  c07a		       20 84 c0 	      jsr	monitor_get_string	; Print the string with surrounding quotes
     18  c07d		       20 bf c0 	      jsr	monitor_parse_command
     19  c080		       4c 70 c0 	      jmp	.monitor_loop
     20  c083		       60		      rts
     21  c084
     22  c084				   monitor_get_string subroutine
     23  c084		       a0 00		      ldy	#$0
     24  c086
     25  c086				   .check_char
      0  c086					      uarta_bytes_available
      1  c086		       a9 01		      lda	#$01
      2  c088		       2c 01 02 	      bit	DUART_STATUS_A
     27  c08b		       f0 1b		      beq	.no_char	; No character available
     28  c08d
      0  c08d					      uarta_getb		; Get byte from UART
      1  c08d		       ad 03 02 	      lda	DUART_RX_A
     30  c090
     31  c090		       c9 0a		      cmp	#$0A	; Check if it's a newline
     32  c092		       f0 22		      beq	.newline
     33  c094		       c9 08		      cmp	#$08	; Check if it's a backspace
     34  c096		       f0 13		      beq	.backspace
     35  c098
     36  c098		       aa		      tax
     37  c099		       c0 7f		      cpy	#$7F	; Make sure buffer doesn't overrun
     38  c09b		       f0 e9		      beq	.check_char
     39  c09d		       8a		      txa
     40  c09e
     41  c09e				   .store_char
     42  c09e		       99 80 00 	      sta	M_STR_BASE,y
     43  c0a1		       c8		      iny
      0  c0a2					      uarta_putb
      1  c0a2		       8d 03 02 	      sta	DUART_TX_A
     45  c0a5		       4c 86 c0 	      jmp	.check_char
     46  c0a8
     47  c0a8				   .no_char
     48  c0a8		       4c 86 c0 	      jmp	.check_char
     49  c0ab
     50  c0ab				   .backspace
     51  c0ab		       c0 00		      cpy	#$0
     52  c0ad		       f0 04		      beq	.backspace_done
     53  c0af		       88		      dey		; Remove character if y > 0
      0  c0b0					      uarta_putb
      1  c0b0		       8d 03 02 	      sta	DUART_TX_A
     55  c0b3				   .backspace_done
     56  c0b3		       4c 86 c0 	      jmp	.check_char
     57  c0b6
     58  c0b6				   .newline
      0  c0b6					      uarta_putb
      1  c0b6		       8d 03 02 	      sta	DUART_TX_A
     60  c0b9		       a9 00		      lda	#$0
     61  c0bb		       99 80 00 	      sta	M_STR_BASE,y	; Add null terminator
     62  c0be		       60		      rts
     63  c0bf
     64  c0bf
     65  c0bf							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     66  c0bf							;
     67  c0bf							; monitor_parse_command
     68  c0bf							;
     69  c0bf							; Parses the command present at MONITOR_STR_BASE
     70  c0bf							;
     71  c0bf							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     72  c0bf
     73  c0bf				   monitor_parse_command subroutine
      0  c0bf					      strlen	M_STR_BASE
      1  c0bf		       a9 80		      lda	#<[M_STR_BASE]
      2  c0c1		       85 00		      sta	$0
      3  c0c3		       a9 00		      lda	#>[M_STR_BASE]
      4  c0c5		       85 01		      sta	$1
      5  c0c7		       20 09 c0 	      jsr	strlen_impl
     75  c0ca		       85 10		      sta	M_STR_LEN
     76  c0cc
     77  c0cc		       a5 80		      lda	M_STR_BASE
     78  c0ce
     79  c0ce							; Check if Intel hex (starts with :)
     80  c0ce		       c9 3a		      cmp	#':
     81  c0d0		       d0 04		      bne	.not_iHex
     82  c0d2		       20 d7 c0 	      jsr	monitor_parse_ihex
     83  c0d5		       60		      rts
     84  c0d6
     85  c0d6				   .not_iHex
     86  c0d6		       60		      rts
     87  c0d7
     88  c0d7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     89  c0d7							;
     90  c0d7							; monitor_parse_ihex
     91  c0d7							;
     92  c0d7							; Parses Intel HEX records
     93  c0d7							;
     94  c0d7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     95  c0d7
     96  c0d7				   monitor_parse_ihex subroutine
     97  c0d7							; Parse Intel HEX format string
     98  c0d7
     99  c0d7							; Check that command is long enough to include record and checksum
    100  c0d7		       a5 10		      lda	M_STR_LEN
    101  c0d9		       c9 0b		      cmp	#$0B	; Check that it's at least 11 bytes long
    102  c0db		       b0 0c		      bcs	.check_record_length
      0  c0dd					      uarta_puts	monitorIntelHexInvalid
      1  c0dd		       a9 34		      lda	#<[monitorIntelHexInvalid]
      2  c0df		       85 00		      sta	$0
      3  c0e1		       a9 c1		      lda	#>[monitorIntelHexInvalid]
      4  c0e3		       85 01		      sta	$1
      5  c0e5		       20 57 c0 	      jsr	uarta_puts_impl
    104  c0e8		       60		      rts
    105  c0e9
    106  c0e9				   .check_record_length
    107  c0e9							; Get the number of data bytes in the record (01-02) and check that the input is
    108  c0e9							; long enough
    109  c0e9
    110  c0e9		       60		      rts
    111  c0ea
    112  c0ea		       47 6f 74 20*gotStrText .byte.b	"Got string: ", $0
    113  c0f7
    114  c0f7		       47 72 69 66*monitorInfoText .byte.b	"Grif65 monitor v0.1 by Andy Best", $0A, $0
    115  c119		       4c 65 6e 67*monitorLengthText .byte.b	"Length: ", $0
    116  c122		       55 6e 6b 6e*monitorUnknownText .byte.b	"Unknown command: ", $0
    117  c134
    118  c134		       49 6e 76 61*monitorIntelHexInvalid .byte.b	"Invalid Intel Hex Record", $0A, $0
    119  c14e
    120  c14e				   monitorHelpText
    121  c14e		       0a		      .byte.b	$0A
    122  c14f		       43 6f 6d 6d*	      .byte.b	"Commands:", $0A
    123  c159		       20 20 3f 20*	      .byte.b	"  ? - Help", $0A
    124  c164		       20 20 61 20*	      .byte.b	"  a - Set address [a XXXX]", $0A
    125  c17f		       0a 00		      .byte.b	$0A, $0
------- FILE main.dasm
     19  c181
     20  c181
     21  c181							; Interrupts
     22  fffa					      org	$FFFA
     23  fffa		       00 c0		      .WORD.w	nmiHandler
     24  fffc		       03 c0		      .WORD.w	resetHandler
     25  fffe		       00 c0		      .WORD.w	irqHandler
