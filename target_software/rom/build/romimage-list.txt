------- FILE main.dasm LEVEL 1 PASS 2
      1  10000 ????						; vim: setlocal ft=asmM6502:
      2  10000 ????
      3  10000 ????				       processor	6502
      4  10000 ????
      5  10000 ????
      6  10000 ????
      7  c000					      org	$C000
      8  c000				   irqHandler
      9  c000				   nmiHandler
     10  c000		       4c 00 c0 	      jmp	*
     11  c003
     12  c003				   resetHandler
     13  c003		       20 65 c0 	      jsr	start_monitor
     14  c006		       4c 06 c0 	      jmp	*	; Shouldn't reach here.
     15  c009
------- FILE utils.dasm LEVEL 2 PASS 2
      0  c009					      include	"utils.dasm"
      1  c009					      processor	6502
      2  c009
      3  c009					      mac	strlen
      4  c009					      lda	#<[{1}]	; Store the address of the string at $0000
      5  c009					      sta	$0
      6  c009					      lda	#>[{1}]
      7  c009					      sta	$1
      8  c009					      jsr	strlen_impl
      9  c009					      endm
     10  c009
     11  c009					      mac	strlen_indir
     12  c009					      lda	{1}	; Store the address of the string at $0000
     13  c009					      sta	$0
     14  c009					      lda	{1} + 1
     15  c009					      sta	$1
     16  c009					      jsr	strlen_impl
     17  c009					      endm
     18  c009
     19  c009				   strlen_impl subroutine		; Stores length of string in acc
     20  c009		       a0 00		      ldy	#0
     21  c00b				   .strlen_loop
     22  c00b		       b1 00		      lda	($0),y
     23  c00d		       f0 04		      beq	.strlen_done
     24  c00f		       c8		      iny
     25  c010		       4c 0b c0 	      jmp	.strlen_loop
     26  c013				   .strlen_done
     27  c013		       98		      tya
     28  c014		       60		      rts
     29  c015
     30  c015				   nibble_to_hex subroutine
     31  c015		       c9 0a		      cmp	#$A
     32  c017		       b0 03		      bcs	.gt_9
     33  c019		       69 30		      adc	#$30	; 0-9, so offset to 0
     34  c01b		       60		      rts
     35  c01c
     36  c01c				   .gt_9		; Greater than 9, so we need to offset to A - 10
     37  c01c		       69 36		      adc	#$36
     38  c01e		       60		      rts
     39  c01f
     40  c01f				   num_to_hex_string subroutine		; Convert num in acc to hex. Stores in $00-$01
     41  c01f		       48		      pha
     42  c020		       29 f0		      and	#$F0
     43  c022		       4a		      lsr
     44  c023		       4a		      lsr
     45  c024		       4a		      lsr
     46  c025		       4a		      lsr
     47  c026		       20 15 c0 	      jsr	nibble_to_hex
     48  c029		       85 00		      sta	$00
     49  c02b		       68		      pla
     50  c02c		       29 0f		      and	#$0F
     51  c02e		       20 15 c0 	      jsr	nibble_to_hex
     52  c031		       85 01		      sta	$01
     53  c033		       60		      rts
     54  c034
     55  c034				   is_hex     subroutine		; Checks if ASCII value in acc is a hex digit
     56  c034		       c9 30		      cmp	#$30
     57  c036		       90 12		      bcc	.not_hex
     58  c038		       c9 3a		      cmp	#$3A
     59  c03a		       b0 03		      bcs	.not_a_number
     60  c03c		       a9 01		      lda	#$1
     61  c03e		       60		      rts
     62  c03f				   .not_a_number
     63  c03f		       c9 41		      cmp	#$41
     64  c041		       90 07		      bcc	.not_hex
     65  c043		       c9 47		      cmp	#$47
     66  c045		       b0 03		      bcs	.not_hex
     67  c047		       a9 01		      lda	#$1
     68  c049		       60		      rts
     69  c04a				   .not_hex
     70  c04a		       a9 00		      lda	#$0
     71  c04c		       60		      rts
     72  c04d
     73  c04d				   hex_to_nibble subroutine		; Convert ascii hex to nibble
     74  c04d		       c9 39		      cmp	#$39	; Is it a letter? (A-F)
     75  c04f		       b0 03		      bcs	.letter
     76  c051		       e9 30		      sbc	#$30
     77  c053		       60		      rts
     78  c054				   .letter
     79  c054		       e9 37		      sbc	#$37
     80  c056		       60		      rts
     81  c057
------- FILE main.dasm
------- FILE uart.dasm LEVEL 2 PASS 2
      0  c057					      include	"uart.dasm"
      1  c057							; vim: setlocal ft=asmM6502:
      2  c057
      3  c057					      processor	6502
      4  c057
      5  c057							; UART Register locations
      6  c057		       02 00	   DUART_BASE equ	$0200
      7  c057		       02 03	   DUART_TX_A equ	DUART_BASE + 3
      8  c057		       02 03	   DUART_RX_A equ	DUART_BASE + 3
      9  c057
     10  c057		       02 01	   DUART_STATUS_A equ	DUART_BASE + 1
     11  c057
     12  c057					      mac	uarta_puts
     13  c057					      lda	#<[{1}]	; Store the address of the string at $0000
     14  c057					      sta	$0
     15  c057					      lda	#>[{1}]
     16  c057					      sta	$1
     17  c057					      jsr	uarta_puts_impl
     18  c057					      endm
     19  c057
     20  c057					      mac	uarta_puts_indir
     21  c057					      lda	{1}	; Store the pointer to the string at $0000
     22  c057					      sta	$0
     23  c057					      lda	{1}+1
     24  c057					      sta	$1
     25  c057					      jsr	uarta_puts_impl
     26  c057					      endm
     27  c057
     28  c057				   uarta_puts_impl subroutine
     29  c057		       a0 00		      ldy	#0
     30  c059				   .uarta_puts_loop
     31  c059		       b1 00		      lda	($0),y
     32  c05b		       f0 07		      beq	.uarta_puts_done
     33  c05d		       8d 03 02 	      sta	DUART_TX_A
     34  c060		       c8		      iny
     35  c061		       4c 59 c0 	      jmp	.uarta_puts_loop
     36  c064				   .uarta_puts_done
     37  c064		       60		      rts
     38  c065
     39  c065
     40  c065					      mac	uarta_putb
     41  c065					      sta	DUART_TX_A
     42  c065					      endm
     43  c065
     44  c065
     45  c065					      mac	uarta_getb
     46  c065					      lda	DUART_RX_A
     47  c065					      endm
     48  c065
     49  c065
     50  c065					      mac	uarta_bytes_available
     51  c065					      lda	#$01	; Perform a bit test on the RX_RDY bit in status reg
     52  c065					      bit	DUART_STATUS_A
     53  c065					      endm
     54  c065
     55  c065
------- FILE main.dasm
------- FILE monitor.dasm LEVEL 2 PASS 2
      0  c065					      include	"monitor.dasm"
      1  c065
      2  c065					      processor	6502
      3  c065
      4  c065		       00 f0	   MONITOR_STR_BASE equ	$F0
      5  c065
      6  c065
      7  c065				   start_monitor subroutine
      0  c065					      uarta_puts	monitorInfoText
      1  c065		       a9 d3		      lda	#<[monitorInfoText]
      2  c067		       85 00		      sta	$0
      3  c069		       a9 c1		      lda	#>[monitorInfoText]
      4  c06b		       85 01		      sta	$1
      5  c06d		       20 57 c0 	      jsr	uarta_puts_impl
      9  c070
     10  c070				   .monitor_loop
     11  c070		       a9 24		      lda	#$24	; Write the prompt ('$ ')
      0  c072					      uarta_putb
      1  c072		       8d 03 02 	      sta	DUART_TX_A
     13  c075		       a9 20		      lda	#$20
      0  c077					      uarta_putb
      1  c077		       8d 03 02 	      sta	DUART_TX_A
     15  c07a
     16  c07a		       20 84 c0 	      jsr	monitor_get_string	; Print the string with surrounding quotes
     17  c07d		       20 06 c1 	      jsr	monitor_parse_command
     18  c080		       4c 70 c0 	      jmp	.monitor_loop
     19  c083		       60		      rts
     20  c084
     21  c084				   monitor_get_string subroutine
     22  c084		       a0 00		      ldy	#$0
     23  c086
     24  c086				   .check_char
      0  c086					      uarta_bytes_available
      1  c086		       a9 01		      lda	#$01
      2  c088		       2c 01 02 	      bit	DUART_STATUS_A
     26  c08b		       f0 15		      beq	.no_char	; No character available
     27  c08d
      0  c08d					      uarta_getb		; Get byte from UART
      1  c08d		       ad 03 02 	      lda	DUART_RX_A
     29  c090
     30  c090		       c9 0a		      cmp	#$0A	; Check if it's a newline
     31  c092		       f0 1c		      beq	.newline
     32  c094		       c9 08		      cmp	#$08	; Check if it's a backspace
     33  c096		       f0 0d		      beq	.backspace
     34  c098
     35  c098				   .store_char
     36  c098		       99 f0 00 	      sta	MONITOR_STR_BASE,y
     37  c09b		       c8		      iny
      0  c09c					      uarta_putb
      1  c09c		       8d 03 02 	      sta	DUART_TX_A
     39  c09f		       4c 86 c0 	      jmp	.check_char
     40  c0a2
     41  c0a2				   .no_char
     42  c0a2		       4c 86 c0 	      jmp	.check_char
     43  c0a5
     44  c0a5				   .backspace
     45  c0a5		       c0 00		      cpy	#$0
     46  c0a7		       f0 04		      beq	.backspace_done
     47  c0a9		       88		      dey		; Remove character if y > 0
      0  c0aa					      uarta_putb
      1  c0aa		       8d 03 02 	      sta	DUART_TX_A
     49  c0ad				   .backspace_done
     50  c0ad		       4c 86 c0 	      jmp	.check_char
     51  c0b0
     52  c0b0				   .newline
      0  c0b0					      uarta_putb
      1  c0b0		       8d 03 02 	      sta	DUART_TX_A
     54  c0b3		       a9 00		      lda	#$0
     55  c0b5		       99 f0 00 	      sta	MONITOR_STR_BASE,y	; Add null terminator
     56  c0b8		       60		      rts
     57  c0b9
     58  c0b9
     59  c0b9							;;; ---------------------------------------------------------------------------
     60  c0b9							;;; Tokenize string into a command and operands.
     61  c0b9							;;;
     62  c0b9							;;; Returns the number of tokens in acc and token pointers in zp $00-$06
     63  c0b9							;;;
     64  c0b9							;;; Modifies A, Y, X and zp $00-06
     65  c0b9							;;; ---------------------------------------------------------------------------
     66  c0b9
     67  c0b9							; Pointers for tokens
     68  c0b9		       00 10	   token1_ptr equ	$0010
     69  c0b9		       00 12	   token2_ptr equ	$0012
     70  c0b9		       00 14	   token3_ptr equ	$0014
     71  c0b9
     72  c0b9					      mac	tokenize_slurp_spaces
     73  c0b9				   .tokenize_slurp_spaces_loop
     74  c0b9					      lda	($0),y
     75  c0b9					      cmp	#$20
     76  c0b9					      bne	.tokenize_slurp_spaces_end
     77  c0b9					      iny
     78  c0b9					      jmp	.tokenize_slurp_spaces_loop
     79  c0b9				   .tokenize_slurp_spaces_end
     80  c0b9					      endm
     81  c0b9
     82  c0b9					      mac	tokenize
     83  c0b9					      lda	#<[{1}]	; Store the address of the string at $0000
     84  c0b9					      sta	$0
     85  c0b9					      lda	#>[{1}]
     86  c0b9					      sta	$1
     87  c0b9
     88  c0b9					      jsr	tokenize_impl
     89  c0b9					      endm
     90  c0b9
     91  c0b9				   tokenize_impl subroutine
     92  c0b9		       a0 00		      ldy	#$0
     93  c0bb		       a2 00		      ldx	#$0
     94  c0bd
     95  c0bd							; Ignore leading spaces
      0  c0bd					      tokenize_slurp_spaces
      1  c0bd				   .tokenize_slurp_spaces_loop
      2  c0bd		       b1 00		      lda	($0),y
      3  c0bf		       c9 20		      cmp	#$20
      4  c0c1		       d0 04		      bne	.tokenize_slurp_spaces_end
      5  c0c3		       c8		      iny
      6  c0c4		       4c bd c0 	      jmp	.tokenize_slurp_spaces_loop
      7  c0c7				   .tokenize_slurp_spaces_end
     97  c0c7
     98  c0c7				   .read_loop
     99  c0c7		       e0 06		      cpx	#$6
    100  c0c9		       f0 38		      beq	.tokenize_done
    101  c0cb		       b1 00		      lda	($0),y	; Load address of input string from zp + y
    102  c0cd		       f0 34		      beq	.tokenize_done	; End of the string
    103  c0cf		       c9 20		      cmp	#$20	; Is it a space?
    104  c0d1		       d0 0d		      bne	.get_token_ptr
    105  c0d3				   .read_loop_got_token
      0  c0d3					      tokenize_slurp_spaces
      1  c0d3				   .tokenize_slurp_spaces_loop
      2  c0d3		       b1 00		      lda	($0),y
      3  c0d5		       c9 20		      cmp	#$20
      4  c0d7		       d0 04		      bne	.tokenize_slurp_spaces_end
      5  c0d9		       c8		      iny
      6  c0da		       4c d3 c0 	      jmp	.tokenize_slurp_spaces_loop
      7  c0dd				   .tokenize_slurp_spaces_end
    107  c0dd		       4c c7 c0 	      jmp	.read_loop
    108  c0e0
    109  c0e0				   .get_token_ptr
    110  c0e0		       18		      clc
    111  c0e1		       98		      tya
    112  c0e2		       65 00		      adc	$0	; Calculate pointer of low byte
    113  c0e4		       95 10		      sta	token1_ptr,x	; Store low byte
    114  c0e6		       a9 00		      lda	#$0
    115  c0e8		       65 01		      adc	$1	; Calculate pointer of high byte
    116  c0ea		       95 11		      sta	token1_ptr + 1,x	; Store high byte
    117  c0ec		       18		      clc
    118  c0ed		       e8		      inx
    119  c0ee		       e8		      inx
    120  c0ef
    121  c0ef				   .get_token_loop		; Skip to the end of the token
    122  c0ef		       b1 00		      lda	($0),y
    123  c0f1		       f0 08		      beq	.token_ptr_done	; Null terminator
    124  c0f3		       c9 20		      cmp	#$20	; Space
    125  c0f5		       f0 04		      beq	.token_ptr_done
    126  c0f7		       c8		      iny
    127  c0f8		       4c ef c0 	      jmp	.get_token_loop
    128  c0fb				   .token_ptr_done
    129  c0fb		       a9 00		      lda	#$0
    130  c0fd		       91 00		      sta	($0),y
    131  c0ff		       c8		      iny
    132  c100		       4c d3 c0 	      jmp	.read_loop_got_token
    133  c103
    134  c103				   .tokenize_done
    135  c103		       8a		      txa		; Transfer pointer offset to acc
    136  c104		       4a		      lsr		; Divide by 2 to get number of tokens
    137  c105		       60		      rts
    138  c106
    139  c106
    140  c106							;;; ---------------------------------------------------------------------------
    141  c106							;;; Parse command entered into monitor
    142  c106							;;;
    143  c106							;;; Tokenizes the input string and executes the command
    144  c106							;;;
    145  c106							;;; Modifies A, Y, X and zp $00-06
    146  c106							;;; ---------------------------------------------------------------------------
    147  c106
    148  c106		       00 16	   MON_CURR_ADDR equ	$0016	; Current address that monitor is looking at
    149  c106
    150  c106				   monitor_parse_command subroutine
      0  c106					      tokenize	MONITOR_STR_BASE
      1  c106		       a9 f0		      lda	#<[MONITOR_STR_BASE]
      2  c108		       85 00		      sta	$0
      3  c10a		       a9 00		      lda	#>[MONITOR_STR_BASE]
      4  c10c		       85 01		      sta	$1
      5  c10e
      6  c10e		       20 b9 c0 	      jsr	tokenize_impl
    152  c111		       85 07		      sta	$7	; Store number of tokens
    153  c113
      0  c113					      strlen_indir	token1_ptr
      1  c113		       a5 10		      lda	token1_ptr
      2  c115		       85 00		      sta	$0
      3  c117		       a5 11		      lda	token1_ptr + 1
      4  c119		       85 01		      sta	$1
      5  c11b		       20 09 c0 	      jsr	strlen_impl
    155  c11e
    156  c11e		       c9 00		      cmp	#$0	; No command
    157  c120		       d0 01		      bne	.check_length
    158  c122		       60		      rts
    159  c123
    160  c123				   .check_length
    161  c123		       c9 01		      cmp	#$1	; Command is single character
    162  c125		       f0 03		      beq	.single_letter_command
    163  c127		       4c 37 c1 	      jmp	.print_unknown
    164  c12a
    165  c12a				   .single_letter_command
    166  c12a		       a5 f0		      lda	MONITOR_STR_BASE
    167  c12c
    168  c12c		       c9 3f		      cmp	#$3F	; ?
    169  c12e		       f0 2d		      beq	.print_help
    170  c130		       c9 61		      cmp	#$61	; a
    171  c132		       f0 37		      beq	.set_address
    172  c134
    173  c134		       4c 37 c1 	      jmp	.print_unknown
    174  c137
    175  c137				   .print_unknown
      0  c137					      uarta_puts	monitorUnknownText
      1  c137		       a9 fe		      lda	#<[monitorUnknownText]
      2  c139		       85 00		      sta	$0
      3  c13b		       a9 c1		      lda	#>[monitorUnknownText]
      4  c13d		       85 01		      sta	$1
      5  c13f		       20 57 c0 	      jsr	uarta_puts_impl
    177  c142		       a9 27		      lda	#$27
      0  c144					      uarta_putb
      1  c144		       8d 03 02 	      sta	DUART_TX_A
      0  c147					      uarta_puts	MONITOR_STR_BASE
      1  c147		       a9 f0		      lda	#<[MONITOR_STR_BASE]
      2  c149		       85 00		      sta	$0
      3  c14b		       a9 00		      lda	#>[MONITOR_STR_BASE]
      4  c14d		       85 01		      sta	$1
      5  c14f		       20 57 c0 	      jsr	uarta_puts_impl
    180  c152		       a9 27		      lda	#$27
      0  c154					      uarta_putb
      1  c154		       8d 03 02 	      sta	DUART_TX_A
    182  c157		       a9 0a		      lda	#$0A
      0  c159					      uarta_putb
      1  c159		       8d 03 02 	      sta	DUART_TX_A
    184  c15c		       60		      rts
    185  c15d
    186  c15d				   .print_help
      0  c15d					      uarta_puts	monitorHelpText
      1  c15d		       a9 60		      lda	#<[monitorHelpText]
      2  c15f		       85 00		      sta	$0
      3  c161		       a9 c2		      lda	#>[monitorHelpText]
      4  c163		       85 01		      sta	$1
      5  c165		       20 57 c0 	      jsr	uarta_puts_impl
    188  c168		       4c c5 c1 	      jmp	.parse_done
    189  c16b
    190  c16b				   .set_address
    191  c16b		       a5 07		      lda	$7	; Load num tokens
    192  c16d		       c9 02		      cmp	#$2	; Expect 2 args
    193  c16f		       d0 2a		      bne	.print_num_args_error
    194  c171
      0  c171					      strlen_indir	token2_ptr	; Token should be a 4 character hex address
      1  c171		       a5 12		      lda	token2_ptr
      2  c173		       85 00		      sta	$0
      3  c175		       a5 13		      lda	token2_ptr + 1
      4  c177		       85 01		      sta	$1
      5  c179		       20 09 c0 	      jsr	strlen_impl
    196  c17c		       c9 04		      cmp	#$4
    197  c17e		       d0 29		      bne	.print_bad_args
    198  c180
    199  c180							; Copy pointer to zp
    200  c180		       a5 12		      lda	token2_ptr
    201  c182		       85 00		      sta	$0
    202  c184		       a5 13		      lda	token2_ptr + 1
    203  c186		       85 01		      sta	$1
    204  c188
    205  c188							; Convert digits to address
    206  c188		       a0 00		      ldy	#$0
    207  c18a
    208  c18a							; Check digits first
    209  c18a				   .digit_check
    210  c18a		       b1 00		      lda	($0),y
    211  c18c		       4c 34 c0 	      jmp	is_hex
    212  c18f		       c9 00		      cmp	#$0
    213  c191		       f0 24		      beq	.print_not_hex
    214  c193		       c8		      iny
    215  c194		       c0 04		      cpy	#$4
    216  c196		       d0 f2		      bne	.digit_check
    217  c198		       4c c5 c1 	      jmp	.parse_done
    218  c19b
    219  c19b				   .print_num_args_error
      0  c19b					      uarta_puts	monitorWrongNumArgsText
      1  c19b		       a9 10		      lda	#<[monitorWrongNumArgsText]
      2  c19d		       85 00		      sta	$0
      3  c19f		       a9 c2		      lda	#>[monitorWrongNumArgsText]
      4  c1a1		       85 01		      sta	$1
      5  c1a3		       20 57 c0 	      jsr	uarta_puts_impl
    221  c1a6		       4c c5 c1 	      jmp	.parse_done
    222  c1a9
    223  c1a9				   .print_bad_args
      0  c1a9					      uarta_puts	monitorBadArgs
      1  c1a9		       a9 2b		      lda	#<[monitorBadArgs]
      2  c1ab		       85 00		      sta	$0
      3  c1ad		       a9 c2		      lda	#>[monitorBadArgs]
      4  c1af		       85 01		      sta	$1
      5  c1b1		       20 57 c0 	      jsr	uarta_puts_impl
    225  c1b4		       4c c5 c1 	      jmp	.parse_done
    226  c1b7
    227  c1b7				   .print_not_hex
      0  c1b7					      uarta_puts	monitorNotHex
      1  c1b7		       a9 48		      lda	#<[monitorNotHex]
      2  c1b9		       85 00		      sta	$0
      3  c1bb		       a9 c2		      lda	#>[monitorNotHex]
      4  c1bd		       85 01		      sta	$1
      5  c1bf		       20 57 c0 	      jsr	uarta_puts_impl
    229  c1c2		       4c c5 c1 	      jmp	.parse_done
    230  c1c5
    231  c1c5
    232  c1c5				   .parse_done
    233  c1c5		       60		      rts
    234  c1c6
    235  c1c6
    236  c1c6		       47 6f 74 20*gotStrText .byte.b	"Got string: ", $0
    237  c1d3
    238  c1d3		       47 72 69 66*monitorInfoText .byte.b	"Grif65 monitor v0.1 by Andy Best", $0A, $0
    239  c1f5		       4c 65 6e 67*monitorLengthText .byte.b	"Length: ", $0
    240  c1fe		       55 6e 6b 6e*monitorUnknownText .byte.b	"Unknown command: ", $0
    241  c210
    242  c210		       57 72 6f 6e*monitorWrongNumArgsText .byte.b	"Wrong number of arguments", $0A, $0
    243  c22b		       41 72 67 75*monitorBadArgs .byte.b	"Arguments in invalid format", $0A, $0
    244  c248		       41 72 67 75*monitorNotHex .byte.b	"Argument not valid hex", $0A, $0
    245  c260
    246  c260				   monitorHelpText
    247  c260		       0a		      .byte.b	$0A
    248  c261		       43 6f 6d 6d*	      .byte.b	"Commands:", $0A
    249  c26b		       20 20 3f 20*	      .byte.b	"  ? - Help", $0A
    250  c276		       20 20 61 20*	      .byte.b	"  a - Set address [a XXXX]", $0A
    251  c291		       0a 00		      .byte.b	$0A, $0
------- FILE main.dasm
     19  c293
     20  c293
     21  c293							; Interrupts
     22  fffa					      org	$FFFA
     23  fffa		       00 c0		      .WORD.w	nmiHandler
     24  fffc		       03 c0		      .WORD.w	resetHandler
     25  fffe		       00 c0		      .WORD.w	irqHandler
