
  processor 6502

MONITOR_STR_BASE: equ $F0


start_monitor subroutine
  uarta_puts monitorInfoText

.monitor_loop:
  lda #$24                    ; Write the prompt ('$ ')
  uarta_putb
  lda #$20
  uarta_putb
  
  jsr monitor_get_string      ; Print the string with surrounding quotes
  jsr monitor_parse_command
  jmp .monitor_loop 
  rts

monitor_get_string subroutine
  ldy #$0

.check_char
  uarta_bytes_available
  beq .no_char                ; No character available
  
  uarta_getb                  ; Get byte from UART
  
  cmp #$0A                    ; Check if it's a newline
  beq .newline
  cmp #$08                    ; Check if it's a backspace
  beq .backspace

.store_char
  sta MONITOR_STR_BASE,y
  iny
  uarta_putb
  jmp .check_char

.no_char
  jmp .check_char
    
.backspace
  cpy #$0
  beq .backspace_done
  dey                         ; Remove character if y > 0
  uarta_putb
.backspace_done
  jmp .check_char
    
.newline
  uarta_putb
  lda #$0
  sta MONITOR_STR_BASE,y      ; Add null terminator
  rts


;;; ---------------------------------------------------------------------------
;;; Tokenize string into a command and operands.
;;;
;;; Returns the number of tokens in acc and token pointers in zp $00-$06
;;; 
;;; Modifies A, Y, X and zp $00-06
;;; ---------------------------------------------------------------------------

; Pointers for tokens
token1_ptr  DS.W 1
token2_ptr  DS.W 1
token3_ptr  DS.W 1

  mac tokenize
    lda #<[{1}]     ; Store the address of the string at $0000
    sta $0
    lda #>[{1}]
    sta $1
  
    jsr tokenize_impl
  endm
  
  mac tokenize_slurp_spaces
.tokenize_slurp_spaces_loop
      lda ($0),y
      cmp #$20
      bne .tokenize_slurp_spaces_end
      iny
      jmp .tokenize_slurp_spaces_loop
.tokenize_slurp_spaces_end
  endm
  
tokenize_impl subroutine
  ldy #$0
  ldx #$0

  ; Ignore leading spaces
  tokenize_slurp_spaces
  
  ; Skip the initial token, since we have its pointer stored already
; .initial_token_loop
;   lda ($0),y
;   beq .tokenize_done      ; End of the string- only one token
;   cmp #$20
;   beq .end_first_token
;   iny
;   jmp .initial_token_loop
  
; .end_first_token
;   lda #$0
;   sta ($0),y      ; Convert the space to a null terminator
;   iny
  
.read_loop
  cpx #$6
  beq .tokenize_done
  lda ($0),y              ; Load address of input string from zp + y
  beq .tokenize_done      ; End of the string
  cmp #$20                ; Is it a space?
  bne .get_token_ptr
.read_loop_got_token
  tokenize_slurp_spaces
  jmp .read_loop

.get_token_ptr
  clc
  tya
  adc $0                  ; Calculate pointer of low byte
  sta token1_ptr,x        ; Store low byte
  lda #$0
  adc $1                  ; Calculate pointer of high byte
  sta token1_ptr + 1,x    ; Store high byte
  clc
  inx
  inx
  
.get_token_loop           ; Skip to the end of the token
  lda ($0),y
  beq .token_ptr_done     ; Null terminator
  cmp #$20                ; Space
  beq .token_ptr_done
  iny
  jmp .get_token_loop
.token_ptr_done
  lda #$0
  sta ($0),y
  iny
  jmp .read_loop_got_token

.tokenize_done
  txa                     ; Transfer pointer offset to acc
  lsr                     ; Divide by 2 to get number of tokens
  rts


;;; ---------------------------------------------------------------------------
;;; Parse command entered into monitor
;;;
;;; Tokenizes the input string and executes the command
;;; 
;;; Modifies A, Y, X and zp $00-06
;;; ---------------------------------------------------------------------------

monitor_parse_command subroutine
  tokenize MONITOR_STR_BASE
  sta $7                        ; Store number of tokens
  
  uarta_puts_indir token1_ptr
  lda #$0A
  uarta_putb
  uarta_puts_indir token2_ptr
  lda #$0A
  uarta_putb
  uarta_puts_indir token3_ptr
  lda #$0A
  uarta_putb
  
  strlen MONITOR_STR_BASE
  
  cmp #$0                       ; No command
  beq .parse_done
  
  cmp #$1                       ; Command is single character
  beq .single_letter_command
  jmp .print_unknown
  
.single_letter_command
  lda MONITOR_STR_BASE
  
  cmp #$3F
  beq .print_help
  jmp .print_unknown
  
.print_unknown
  uarta_puts monitorUnknownText
  lda #$27
  uarta_putb
  uarta_puts MONITOR_STR_BASE
  lda #$27
  uarta_putb
  lda #$0A
  uarta_putb
  rts
  
.print_help
  uarta_puts monitorHelpText
  jmp .parse_done
  
.parse_done
  rts
  
  
gotStrText: .byte "Got string: ", $0

monitorInfoText: .byte "Grif65 monitor v0.1 by Andy Best", $0A, $0
monitorLengthText: .byte "Length: ", $0
monitorUnknownText: .byte "Unknown command: ", $0

monitorHelpText: 
  .byte $0A
  .byte "Commands:", $0A
  .byte "  ? - Help", $0A
  .byte "  p - Print Memory", $0A
  .byte $0A, $0